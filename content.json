{"meta":{"title":"TispyDr","subtitle":"zxh","description":"一叶知秋，须臾不朽","author":"Tispy Dr","url":"http://zhuxiaohan.xyz","root":"/"},"pages":[{"title":"about","date":"2022-01-21T09:17:18.000Z","updated":"2023-01-31T04:02:21.087Z","comments":true,"path":"about/index.html","permalink":"http://zhuxiaohan.xyz/about/","excerpt":"","text":""},{"title":"文章分类","date":"2023-01-31T04:02:21.089Z","updated":"2023-01-31T04:02:21.089Z","comments":true,"path":"categories/index.html","permalink":"http://zhuxiaohan.xyz/categories/","excerpt":"","text":""},{"title":"","date":"2023-01-31T04:02:21.089Z","updated":"2023-01-31T04:02:21.089Z","comments":true,"path":"css/background.css","permalink":"http://zhuxiaohan.xyz/css/background.css","excerpt":"","text":"body { cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur), default; } a, img { cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur), default; } /* 页脚footer */ /* 渐变色滚动动画 */ @-webkit-keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } @-moz-keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } @keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } #footer { background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab); background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite; -o-user-select: none; -ms-user-select: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; border-top-left-radius: 10px; border-top-right-radius: 10px; } #footer:before { background-color: rgba(0, 0, 0, 0); } /* 背景图片 */ #web_bg { background: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35)), url(\"https://ae01.alicdn.com/kf/H21b5f6b8496141a1979a33666e1074d9x.jpg\") !important; } /* 字体 */ @font-face { font-family: 'tzy'; /* 字体名自定义即可 */ src: url('https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/font/ZhuZiAWan.woff2'); /* 字体文件路径 */ font-display: swap; } body, .gitcalendar { font-family: tzy !important; } /* 滚动条一 */ ::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { background-color: rgba(73, 177, 245, 0.2); border-radius: 2em; } ::-webkit-scrollbar-thumb { background-color: #49b1f5; background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.4) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0.4) 75%, transparent 75%, transparent); border-radius: 2em; } ::-webkit-scrollbar-corner { background-color: transparent; } ::-moz-selection { color: #fff; background-color: #49b1f5; } /* 滚动条二 */ /* ::-webkit-scrollbar { width: 8px; height: 8px } ::-webkit-scrollbar-track { border-radius: 2em; } ::-webkit-scrollbar-thumb { background-color: rgb(255 255 255 / .3); background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent); border-radius: 2em } ::-webkit-scrollbar-corner { background-color: transparent } */"},{"title":"friends","date":"2022-01-21T09:17:18.000Z","updated":"2023-01-31T04:02:21.090Z","comments":true,"path":"friends/index.html","permalink":"http://zhuxiaohan.xyz/friends/","excerpt":"","text":""},{"title":"图库","date":"2023-01-31T04:02:21.090Z","updated":"2023-01-31T04:02:21.090Z","comments":true,"path":"image/index.html","permalink":"http://zhuxiaohan.xyz/image/","excerpt":"","text":"lbxx 关于lbxx的图片 lele 关于lele的图片"},{"title":"友情链接","date":"2023-01-31T04:02:21.111Z","updated":"2023-01-31T04:02:21.111Z","comments":true,"path":"link/index.html","permalink":"http://zhuxiaohan.xyz/link/","excerpt":"","text":""},{"title":"图库","date":"2023-01-31T04:02:21.111Z","updated":"2023-01-31T04:02:21.111Z","comments":true,"path":"movie/index.html","permalink":"http://zhuxiaohan.xyz/movie/","excerpt":"","text":"lele 关于lele的电影"},{"title":"标籤","date":"2023-01-31T04:02:21.112Z","updated":"2023-01-31T04:02:21.112Z","comments":true,"path":"tags/index.html","permalink":"http://zhuxiaohan.xyz/tags/","excerpt":"","text":""},{"title":"projects","date":"2022-01-21T09:56:40.000Z","updated":"2023-01-31T04:02:21.112Z","comments":true,"path":"project/index.html","permalink":"http://zhuxiaohan.xyz/project/","excerpt":"","text":""},{"title":"文章分类","date":"2023-01-31T04:02:21.088Z","updated":"2023-01-31T04:02:21.088Z","comments":true,"path":"blog/categories/index.html","permalink":"http://zhuxiaohan.xyz/blog/categories/","excerpt":"","text":""},{"title":"lbxx","date":"2023-01-31T04:02:21.090Z","updated":"2023-01-31T04:02:21.090Z","comments":true,"path":"image/lbxx/index.html","permalink":"http://zhuxiaohan.xyz/image/lbxx/","excerpt":"","text":""},{"title":"所有标签","date":"2023-01-31T04:02:21.088Z","updated":"2023-01-31T04:02:21.088Z","comments":true,"path":"blog/tags/index.html","permalink":"http://zhuxiaohan.xyz/blog/tags/","excerpt":"","text":""},{"title":"lele","date":"2023-01-31T04:02:21.091Z","updated":"2023-01-31T04:02:21.091Z","comments":true,"path":"image/lele/index.html","permalink":"http://zhuxiaohan.xyz/image/lele/","excerpt":"","text":""},{"title":"lele","date":"2023-01-31T04:02:21.112Z","updated":"2023-01-31T04:02:21.112Z","comments":true,"path":"movie/lele/index.html","permalink":"http://zhuxiaohan.xyz/movie/lele/","excerpt":"","text":""}],"posts":[{"title":"git cherry-pick 操作","slug":"git-cherry-pick-操作","date":"2022-10-27T05:31:00.000Z","updated":"2023-01-31T04:02:21.080Z","comments":true,"path":"2022/10/27/git-cherry-pick-操作/","link":"","permalink":"http://zhuxiaohan.xyz/2022/10/27/git-cherry-pick-%E6%93%8D%E4%BD%9C/","excerpt":"","text":"对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。 这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。 git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。 1$ git cherry-pick &lt;commitHash&gt; 上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。 举例来说，代码仓库有master和feature两个分支。 123a - b - c - d Master \\ e - f - g Feature 现在将提交f应用到master分支。 切换到 master 分支1$ git checkout master Cherry pick 操作1$ git cherry-pick f 上面的操作完成以后，代码库就变成了下面的样子。 a - b - c - d - f Master \\ e - f - g Feature 从上面可以看到，master分支的末尾增加了一个提交f。 git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。 1$ git cherry-pick feature 上面代码表示将feature分支的最近一次提交，转移到当前分支。 Cherry pick 支持一次转移多个提交。 $ git cherry-pick 上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。 如果想要转移一系列的连续提交，可以使用下面的简便语法。 1$ git cherry-pick A..B 上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。 注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。 1$ git cherry-pick A^..B git cherry-pick命令的常用配置项如下。 （1）-e，–edit 打开外部编辑器，编辑提交信息。 （2）-n，–no-commit 只更新工作区和暂存区，不产生新的提交。 （3）-x 在提交信息的末尾追加一行(cherry picked from commit …)，方便以后查到这个提交是如何产生的。 （4）-s，–signoff 在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。 （5）-m parent-number，–mainline parent-number 如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。 -m配置项告诉 Git，应该采用哪个分支的变动。它的参数parent-number是一个从1开始的整数，代表原始提交的父分支编号。 $ git cherry-pick -m 1 上面命令表示，Cherry pick 采用提交commitHash来自编号1的父分支的变动。 一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。 如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。 （1）–continue 用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。 1$ git cherry-pick --continue （2）–abort 发生代码冲突后，放弃合并，回到操作前的样子。 （3）–quit 发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。 Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。 1$ git remote add target git://gitUrl 上面命令添加了一个远程仓库target。 然后，将远程代码抓取到本地。 1$ git fetch target 上面命令将远程代码仓库抓取到本地。 接着，检查一下要从远程仓库转移的提交，获取它的哈希值。 1$ git log target/master 最后，使用git cherry-pick命令转移提交。 1$ git cherry-pick &lt;commitHash&gt;","categories":[],"tags":[],"author":"Tispy Dr"},{"title":"利用 three 绘制图片以及标注数据","slug":"利用-three-绘制图片以及标注数据","date":"2022-07-28T11:12:00.000Z","updated":"2023-01-31T04:02:21.083Z","comments":true,"path":"2022/07/28/利用-three-绘制图片以及标注数据/","link":"","permalink":"http://zhuxiaohan.xyz/2022/07/28/%E5%88%A9%E7%94%A8-three-%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E4%BB%A5%E5%8F%8A%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE/","excerpt":"","text":"效果展示 实现最开始想的是用 canvas 绘制的，因为 canvas 不需要还是比较方便和小的，但是考虑到后续可能会有手动标注的部分，而且 three 功能很全什么形状都可以绘制而且为了技术统一性，索性就用了 three 去绘制图像和标注结果 代码废话不多说 最后封装的成品代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221import * as THREE from &#x27;three&#x27;;export class Viewer &#123; width: number; height: number; ref: any; constructor(options: any) &#123; options = options || &#123;&#125;; this.width = options.width || 1280; this.height = options.height || 720; this.ref = options.ref; this.init(); &#125; _render: any = null; _scene: any = null; init = () =&gt; &#123; const renderer = this.initRender(); const scene = this.initScene(); const camera = this.initCamera(); const render = () =&gt; &#123; renderer.render(scene, camera); &#125;; this._render = render; scene.add(camera); render(); &#125;; //设置背景颜色 initRender = () =&gt; &#123; const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;); renderer.setSize(this.width, this.height); // renderer.setClearColor(0xffffff, 0.1); this.ref &amp;&amp; this.ref.appendChild(renderer.domElement); return renderer; &#125;; initScene = () =&gt; &#123; const scene = new THREE.Scene(); scene.autoUpdate = true; this._scene = scene; return scene; &#125;; initCamera = () =&gt; &#123; const camera = new THREE.PerspectiveCamera( 45, this.width / this.height, 1, 2000, ); camera.position.set(0, 0, 880); camera.lookAt(new THREE.Vector3(0, 0, 0)); return camera; &#125;; // 辅助线 addAxisHelper = () =&gt; &#123; const axisHelper = new THREE.AxesHelper(360); this._scene &amp;&amp; this._scene.add(axisHelper); &#125;; drawLabel = (position: any, label: string, color?: string) =&gt; &#123; let canvas: any = document.createElement(&#x27;canvas&#x27;); canvas.width = 40; canvas.height = 14; const ctx: any = canvas.getContext(&#x27;2d&#x27;); ctx.fillStyle = color || &#x27;#fe0101&#x27;; ctx.font = &#x27;Bold 14px 宋体&#x27;; ctx.fillText(label, 0, 14); const texture = new THREE.CanvasTexture(canvas); const material = new THREE.SpriteMaterial(&#123; map: texture &#125;); const text = new THREE.Sprite(material); text.position.set(position.x - 640, -position.y + 360 - 10, 0); text.scale.set(40, 20, 1); canvas = null; return text; &#125;; drawBox = (position: any, dimension: any, color?: string, label?: string) =&gt; &#123; const geometry = new THREE.PlaneGeometry(dimension.x, dimension.y); const edges = new THREE.EdgesGeometry(geometry); const edgesMaterial = new THREE.LineBasicMaterial(&#123; color: color || 0xff0000, &#125;); const plane = new THREE.LineSegments(edges, edgesMaterial); plane.position.set(position.x - 640, -position.y + 360, 0); this._scene &amp;&amp; this._scene.add(plane); if (label) &#123; const text = this.drawLabel(position, label, color); this._scene &amp;&amp; this._scene.add(text); &#125; &#125;; drawPoints = (data: &#123; points: string; label: string; color: string &#125;) =&gt; &#123; const &#123; points: _points, label, color &#125; = data; if (!_points) &#123; return; &#125; const position = &#123; x: +_points.split(&#x27;,&#x27;)[0], y: +_points.split(&#x27;,&#x27;)[1], &#125;; const geometry = new THREE.CircleGeometry(5, 32); const material = new THREE.MeshBasicMaterial(&#123; color: color || 0xff0000 &#125;); const points = new THREE.Mesh(geometry, material); points.position.set(position.x - 640, -position.y + 360, 0); if (label) &#123; const text = this.drawLabel(position, label, color); this._scene &amp;&amp; this._scene.add(text); &#125; this._scene &amp;&amp; this._scene.add(points); &#125;; drawPolyline = (points: any, color?: string) =&gt; &#123; if (!points) &#123; return; &#125; const curveArr = points.map((item: any) =&gt; &#123; return new THREE.Vector2( +item.split(&#x27;,&#x27;)[0] - 640, +item.split(&#x27;,&#x27;)[1] - 360, ); &#125;); const curve = new THREE.SplineCurve(curveArr); const _points = curve.getPoints(30); const geometry = new THREE.BufferGeometry().setFromPoints(_points); const material = new THREE.LineBasicMaterial(&#123; color: color || 0xff0000 &#125;); const splineObject = new THREE.Line(geometry, material); this._scene &amp;&amp; this._scene.add(splineObject); &#125;; drawMarker = (data: any) =&gt; &#123; // this._scene &amp;&amp; this.addAxisHelper(); if (!data) return; const &#123; location, points, box, polyline &#125; = data; points &amp;&amp; this.drawPoints(points); box &amp;&amp; box.forEach((item: any) =&gt; &#123; const &#123; xbr, xtl, ybr, ytl, color, label &#125; = item; const position = &#123; x: (+xtl + +xbr) / 2, y: (+ytl + +ybr) / 2, &#125;; const dimension = &#123; x: Math.abs(xbr - xtl), y: Math.abs(ybr - ytl), &#125;; this.drawBox(position, dimension, color, label); &#125;); polyline &amp;&amp; polyline.forEach((item: any) =&gt; &#123; const &#123; points, color &#125; = item; this.drawPolyline(points, color); &#125;); location &amp;&amp; location.forEach((item: any) =&gt; &#123; const &#123; position, dimension, color, label &#125; = item; const _position = &#123; x: position.x - dimension.x / 2, y: position.y - dimension.y / 2, &#125;; this.drawBox(_position, dimension, color, label); &#125;); this._render &amp;&amp; this._render(); &#125;; getImage2D = (path: string, callback?: any) =&gt; &#123; const planeGeometry = new THREE.PlaneBufferGeometry(1280, 720); new THREE.TextureLoader().load(path, texture =&gt; &#123; const planeMaterial = new THREE.MeshBasicMaterial(&#123; map: texture, side: THREE.DoubleSide, &#125;); const plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.renderOrder = -10; this._scene &amp;&amp; this._scene.add(plane); this._render &amp;&amp; this._render(); callback &amp;&amp; callback(); &#125;); &#125;;&#125; 如何使用呢使用的代码如下，根据我们的业务场景把处理 loader 加载 pcd 文件的部分放到了外边文件中 下边代码中只有主要的逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import &#123; Viewer &#125; from &#x27;@/utils/viewers/pcdViewer&#x27;;// 获取 pcd 数据并返回 object3D 模型const getPoints = (path: string) =&gt; &#123; setLoading(true); viewer.current._loader.load( replaceHttpToHttps(path), (points: any) =&gt; &#123; // points.geometry.center(); points.material.color.setHex(0xffffff); points.material.vertexColors = true; viewer.current.removePoints(); if (colorMap.current) &#123; const position = points.geometry.attributes.position.array; const size = points.geometry.attributes.position.count; const colors = colorMap.current &amp;&amp; viewer.current.addColors(position, size, colorMap.current); points.geometry.setAttribute(&#x27;color&#x27;, colors); &#125; viewer.current.addPoints(points); viewer.current._render(); &#125;, (xhr: any) =&gt; &#123; if (xhr.loaded / xhr.total === 1) &#123; setLoading(false); &#125; &#125;, (error: Error) =&gt; &#123; console.log(&#x27;An error happened the content is: &#x27;, error); &#125;, );&#125;;// 初始化 视图useEffect(() =&gt; &#123; const &#123; height: h, width: w &#125; = threeRef.current &amp;&amp; threeRef.current.getBoundingClientRect(); viewer.current = new Viewer(&#123; width: w, height: h, ref: threeRef.current, &#125;); getPoints(path); return () =&gt; &#123; colorMap.current = null; threeRef.current = null; viewer.current = null; &#125;;&#125;, []);// returnreturn ( &lt;ThreeWrapper ref=&#123;threeRef&#125;&gt; &#123;loading ? ( &lt;PointLoading style=&#123;&#123; position: &#x27;absolute&#x27;, top: 0, zIndex: 10, &#125;&#125; modalStyle=&#123;&#123; opacity: 0.6, background: &#x27;#000&#x27;, &#125;&#125; tip=&quot;加载中...&quot; /&gt; ) : null&#125; &lt;ColorMap onChange=&#123;handleColorMapChange&#125; /&gt; &lt;/ThreeWrapper&gt; );","categories":[{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/categories/react/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"threejs","slug":"threejs","permalink":"http://zhuxiaohan.xyz/tags/threejs/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"}],"author":"Tispy Dr"},{"title":"利用 three 可视化pcd文件的自动驾驶数据","slug":"利用-three-可视化pcd文件的自动驾驶数据","date":"2022-07-28T10:03:00.000Z","updated":"2023-01-31T04:02:21.083Z","comments":true,"path":"2022/07/28/利用-three-可视化pcd文件的自动驾驶数据/","link":"","permalink":"http://zhuxiaohan.xyz/2022/07/28/%E5%88%A9%E7%94%A8-three-%E5%8F%AF%E8%A7%86%E5%8C%96pcd%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%95%B0%E6%8D%AE/","excerpt":"","text":"效果展示 实现我们现在项目所使用的点云的文件是 pcd 格式的，我们点云选取的可视化方式是使用 threejs 的 pcdloader，不过 pcdloader 的作用是分析 pcd 二进制结构并返回一个 Object3D 实例。该 Object3D 实例实际类型为 Points，由一个 BufferGeometry 实例和一个 PointsMaterial 实例作为参数构造而成的，所以这种点云是没有色彩的点云，是只有一种颜色的点云，所以为了更够更清楚的展示我们的点云，所以我们要根据 positions 自己计算出点云的颜色，并映射出来。然后我们把这个最后再通过 three 搭建场景、相机、控制器、渲染器的方式渲染出来就是我们看到的点云了 代码废话不多说 最后封装的成品代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256import * as THREE from &#x27;three&#x27;;// import &#123; TrackballControls &#125; from &#x27;three/examples/jsm/controls/TrackballControls.js&#x27;;import &#123; OrbitControls &#125; from &#x27;three/examples/jsm/controls/OrbitControls.js&#x27;;import &#123; PCDLoader &#125; from &#x27;three/examples/jsm/loaders/PCDLoader.js&#x27;;import &#123; debounce &#125; from &#x27;@/utils&#x27;;export class Viewer &#123; width: number; height: number; ref: any; constructor(options: any) &#123; options = options || &#123;&#125;; this.width = options.width; this.height = options.height; this.ref = options.ref; this.init(); &#125; _scene: any = null; _render: any = null; _points: any = null; _camera: any = null; _loader: any = null; _controls: any = null; _renderer: any = null; init = () =&gt; &#123; const renderer = this.initRender(); const scene = this.initScene(); const camera = this.initCamera(); const light = this.initLight(); const render = () =&gt; &#123; renderer.render(scene, camera); &#125;; this._render = render; scene.add(camera); scene.add(light); this.initControls(); this.animate(); this.initLoader(); window.addEventListener(&#x27;resize&#x27;, this.debounceOnWindowResize); render(); &#125;; onWindowResize = () =&gt; &#123; const &#123; height: h, width: w &#125; = this.ref &amp;&amp; this.ref.getBoundingClientRect(); this.height = h; this.width = w; this._camera.aspect = w / h; this._camera.updateProjectionMatrix(); this._renderer.setSize(w, h); &#125;; debounceOnWindowResize = debounce(this.onWindowResize, 300); animate = () =&gt; &#123; //更新控制器 this._controls &amp;&amp; this._controls.update(); this._render &amp;&amp; this._render(); requestAnimationFrame(this.animate); &#125;; //设置背景颜色 initRender = () =&gt; &#123; const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;); renderer.setSize(this.width, this.height); this.ref &amp;&amp; this.ref.appendChild(renderer.domElement); this._renderer = renderer; return renderer; &#125;; initControls = () =&gt; &#123; this._controls = new OrbitControls(this._camera, this._renderer.domElement); // use if there is no animation loop // controls.addEventListener(&#x27;change&#x27;, render); // controls.update(); &#125;; initLoader = () =&gt; &#123; this._loader = new PCDLoader(); &#125;; initScene = () =&gt; &#123; const scene = new THREE.Scene(); scene.autoUpdate = true; this._scene = scene; this.addAxisHelper(); return scene; &#125;; initLight = () =&gt; &#123; const light = new THREE.DirectionalLight(0xffffff); light.position.set(1, 1, 1); return light; &#125;; initCamera = () =&gt; &#123; const camera = new THREE.PerspectiveCamera( 45, this.width / this.height, 1, 10000, ); camera.position.set(-100, 0, 100); camera.up.set(0, 0, 1); camera.lookAt(200); this._camera = camera; return camera; &#125;; addPoints = (points: any) =&gt; &#123; this._points = points; this._scene.add(this._points); &#125;; removePoints = () =&gt; &#123; this._scene.remove(this._points); &#125;; // 辅助线 addAxisHelper = () =&gt; &#123; const axisHelper = new THREE.AxesHelper(50); this._scene.add(axisHelper); &#125;; drawBox = (data: any) =&gt; &#123; this._scene &amp;&amp; this.addAxisHelper(); if (!data || data.length &lt;= 0) &#123; return; &#125; data.forEach((item: any) =&gt; &#123; const geometry = new THREE.BoxGeometry( item?.scale?.x, item?.scale?.y, item?.scale?.z, ); const mesh = new THREE.Mesh(geometry); item?.rotation &amp;&amp; mesh.rotation.set(item.rotation?.x, item.rotation?.y, item.rotation?.z); item?.position &amp;&amp; mesh.position.set(item.position?.x, item.position?.y, item.position?.z); const box = new THREE.BoxHelper(mesh, 0x00ff00); this._scene.add(box); if (item?.category &amp;&amp; item?.position) &#123; const label = this.drawLabel( item?.position, item?.category, item?.scale, ); this._scene.add(label); &#125; &#125;); &#125;; drawLine = (data: any) =&gt; &#123; if (!data || data.length &lt;= 0) &#123; return; &#125; data.forEach((item: any) =&gt; &#123; const material = new THREE.LineBasicMaterial(&#123; color: item?.color || 0xffff00, linewidth: 5, linecap: &#x27;round&#x27;, //ignored by WebGLRenderer linejoin: &#x27;round&#x27;, &#125;); const geometry = new THREE.BufferGeometry(); const pointsArray = item?.points.map((points: number[]) =&gt; &#123; return new THREE.Vector3(...points); &#125;); geometry.setFromPoints(pointsArray); const line = new THREE.Line(geometry, material); this._scene.add(line); &#125;); &#125;; drawLabel = (position: any, label: string, color?: string) =&gt; &#123; const canvas = document.createElement(&#x27;canvas&#x27;); canvas.width = 40; canvas.height = 14; const ctx: any = canvas.getContext(&#x27;2d&#x27;); ctx.fillStyle = color || &#x27;#fe0101&#x27;; ctx.font = &#x27;Bold 14px 宋体&#x27;; ctx.fillText(label, 0, 14); document.body.appendChild(canvas); const texture = new THREE.CanvasTexture(canvas); const material = new THREE.SpriteMaterial(&#123; map: texture &#125;); const text = new THREE.Sprite(material); text.position.set(position.x, position.y, position.z); text.scale.set(0.2, 0.2, 0.2); return text; &#125;; addColors = (position: number[], size: number, colormapCtx: any) =&gt; &#123; const values = []; for (let i = 0; i &lt; size; i++) &#123; const index = i * 3 + 2; values.push(position[index]); &#125; let max = -Infinity; let min = Infinity; for (const i of values) &#123; if (max &lt; i) max = i; if (min &gt; i) min = i; &#125; const colors = new Float32Array(size * 3); for (let i = 0; i &lt; size; i++) &#123; let index = Math.floor(((values[i] - min) / (max - min)) * 255); if (!isFinite(index)) index = 0; const data = colormapCtx.getImageData(index, 5, 1, 1).data; colors[i * 3 + 0] = data[0] / 255.0; colors[i * 3 + 1] = data[1] / 255.0; colors[i * 3 + 2] = data[2] / 255.0; &#125; return new THREE.BufferAttribute(colors, 3); &#125;;&#125; 如果使用呢使用的代码如下，根据我们的业务场景把处理 loader 加载 pcd 文件的部分放到了外边文件中 下边代码中只有主要的逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; Viewer &#125; from &#x27;@/utils/viewers/pcdViewer&#x27;;// 初始化 视图useEffect(() =&gt; &#123; viewer.current = new Viewer(&#123; width: 1280, height: 720, ref: slideRef.current, &#125;); viewer.current?.getImage2D(path, () =&gt; &#123; setIsLoading(false); &#125;); return () =&gt; &#123; slideRef.current = null; viewer.current = null; &#125;;&#125;, []);// returnreturn ( &lt;ImageWrapper margin=&#123;margin&#125; width=&#123;width&#125; height=&#123;height&#125;&gt; &lt;ImageContent ref=&#123;slideRef&#125;&gt; &lt;ImageWay&gt;&#123;ids[currentCamera]&#125;&lt;/ImageWay&gt; &#123;isLoading ? ( &lt;PointLoading style=&#123;&#123; position: &#x27;absolute&#x27;, width: &#x27;100%&#x27;, height: &#x27;100%&#x27; &#125;&#125; /&gt; ) : null&#125; &#123;isEmpty ? ( &lt;img src=&#123;emptyPng&#125; height=&#123;height&#125; style=&#123;&#123; position: &#x27;absolute&#x27;, top: &#x27;0&#x27; &#125;&#125; /&gt; ) : null&#125; &lt;/ImageContent&gt; &lt;/ImageWrapper&gt; );","categories":[{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/categories/react/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"threejs","slug":"threejs","permalink":"http://zhuxiaohan.xyz/tags/threejs/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"}],"author":"Tispy Dr"},{"title":"点云赋色","slug":"点云赋色","date":"2022-07-08T05:24:00.000Z","updated":"2023-01-31T04:02:21.085Z","comments":true,"path":"2022/07/08/点云赋色/","link":"","permalink":"http://zhuxiaohan.xyz/2022/07/08/%E7%82%B9%E4%BA%91%E8%B5%8B%E8%89%B2/","excerpt":"","text":"需求需求是这样的，我们现在项目所使用的点云的文件是 pcd 格式的，我们点云选取的可视化方式是使用 threejs 的pcdloader，不过 pcdloader 的作用是分析 pcd 二进制结构并返回一个 Object3D 实例。该 Object3D 实例实际类型为 Points，由一个 BufferGeometry 实例和一个 PointsMaterial 实例作为参数构造而成的，所以这种点云是没有色彩的点云，是只有一种颜色的点云，所以为了更够更清楚的展示我们的点云，所以我们要根据 positions 自己计算出点云的颜色，并映射出来。 点云颜色映射的方式是通过 几张预设得到 colorMap 的图片然后利用 canvas 绘制出来，然后再根据点云信息中的 x，y，z或者 FIELDS 中的其他值映射出来的 colorMap 组件代码colorMap组件的作用是生成点云映射颜色的 map 信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// index.tsximport &#123; FC, useEffect, useRef &#125; from &#x27;react&#x27;;import &#123; ColorMapList, ColorMapCurrent, ColorMapCanvas,&#125; from &#x27;./styled&#x27;;import whiteUri from &#x27;@/assets/colorMap/colorscale_white.png&#x27;;import rainbowUri from &#x27;@/assets/colorMap/colorscale_rainbow.jpg&#x27;;import boneUri from &#x27;@/assets/colorMap/colorscale_bone.jpg&#x27;;import coolUri from &#x27;@/assets/colorMap/colorscale_cool.jpg&#x27;;import hotUri from &#x27;@/assets/colorMap/colorscale_hot.jpg&#x27;;import hsvUri from &#x27;@/assets/colorMap/colorscale_hsv.jpg&#x27;;import jetUri from &#x27;@/assets/colorMap/colorscale_jet.jpg&#x27;;import oceanUri from &#x27;@/assets/colorMap/colorscale_ocean.jpg&#x27;;import parulaUri from &#x27;@/assets/colorMap/colorscale_parula.jpg&#x27;;const colorMaps = [ whiteUri, rainbowUri, boneUri, coolUri, hotUri, hsvUri, jetUri, oceanUri, parulaUri,];interface Props &#123; onChange: (data: any) =&gt; void;&#125;const ColorMap: FC&lt;Props&gt; = props =&gt; &#123; const &#123; onChange &#125; = props; const colorMap: any = useRef(null); const handleChangeColor = (index: number) =&gt; &#123; if (colorMap.current) &#123; const colormapCtx = colorMap.current.getContext(&#x27;2d&#x27;); const img: any = document.getElementById(`colorMap$&#123;index&#125;`); img.onload = () =&gt; &#123; colormapCtx.drawImage(img, 0, 0); &#125;; colormapCtx.drawImage(img, 0, 0); onChange &amp;&amp; onChange(colormapCtx); &#125; &#125;; useEffect(() =&gt; &#123; handleChangeColor(0); &#125;, []) return ( &lt;ColorMapCurrent&gt; &lt;ColorMapList className=&quot;colorMapList&quot;&gt; &#123;colorMaps.map((item, index) =&gt; &#123; return ( &lt;div key=&#123;index&#125; onClick=&#123;() =&gt; &#123; handleChangeColor(index); &#125;&#125; &gt; &lt;img src=&#123;item&#125; id=&#123;`colorMap$&#123;index&#125;`&#125; /&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/ColorMapList&gt; &lt;ColorMapCanvas id=&quot;colorMap&quot; ref=&#123;colorMap&#125; width=&quot;256px&quot; height=&quot;10px&quot; &gt;&lt;/ColorMapCanvas&gt; &lt;/ColorMapCurrent&gt; );&#125;;export default ColorMap; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// styled.tsximport styled from &#x27;styled-components&#x27;;export const ColorMapList = styled.div` position: absolute; bottom: 42px; z-index: 1; &amp; &gt; div &#123; background-color: rgba(255, 255, 255, 0.3); position: relative; width: calc(256px + 32px); height: calc(10px + 32px); z-index: 1; &#125; &amp; &gt; div:hover &#123; background-color: rgba(255, 255, 255, 0.8); cursor: pointer; &#125; &amp; &gt; div &gt; img &#123; position: absolute; top: 16px; left: 16px; width: 256px; height: 10px; &#125;`;export const ColorMapCurrent = styled.div` position: absolute; left: 16px; bottom: 16px; display: flex; justify-content: center; align-items: center; width: calc(256px + 32px); height: calc(10px + 32px); z-index: 1; &amp; &gt; .colorMapList &#123; display: none; &#125; &amp;:hover &#123; background-color: rgba(255, 255, 255, 0.2); cursor: pointer; .colorMapList &#123; display: block; &#125; &#125;`;export const ColorMapCanvas = styled.canvas` position: absolute; width: 256px; height: 10px; z-index: 1;`; 在three pcdLoader 中使用的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071let _points: any = null;const addColors = ( position: number[], size: number, colormapCtx: any,) =&gt; &#123; let values = []; for (let i = 0; i &lt; size; i++) &#123; const index = i * 3 + 2; values.push(position[index]); &#125; let max = -Infinity; let min = Infinity; for (let i of values) &#123; if (max &lt; i) max = i; if (min &gt; i) min = i; &#125; let colors = new Float32Array(size * 3); for (let i = 0; i &lt; size; i++) &#123; let index = Math.floor(((values[i] - min) / (max - min)) * 255); if (!isFinite(index)) index = 0; let data = colormapCtx.getImageData(index, 5, 1, 1).data; colors[i * 3 + 0] = data[0] / 255.0; colors[i * 3 + 1] = data[1] / 255.0; colors[i * 3 + 2] = data[2] / 255.0; &#125; return new THREE.BufferAttribute(colors, 3);&#125;;const getPoints = (path: string) =&gt; &#123; setLoading(true); _loader.load( replaceHttpToHttps(path), (points: any) =&gt; &#123; points.material.color.setHex(0xffffff); points.material.vertexColors = true; _scene.remove(_points); const position = points.geometry.attributes.position.array; const size = points.geometry.attributes.position.count; const colors = addColors(position, size, colorMap.current); points.geometry.setAttribute(&#x27;color&#x27;, colors); _points = points; _scene.add(points); _render(); &#125;, (xhr: any) =&gt; &#123; if (xhr.loaded / xhr.total === 1) &#123; setLoading(false); &#125; &#125;, (error: Error) =&gt; &#123; console.log(&#x27;An error happened the content is: &#x27;, error); &#125;, );&#125;;const handleColorMapChange = (colormapCtx: any) =&gt; &#123; colorMap.current = colormapCtx; const position = _points?.geometry.attributes.position.array; const size = _points?.geometry.attributes.position.count; const colors = addColors(position, size, colorMap.current); _points?.geometry.setAttribute(&#x27;color&#x27;, colors); _render &amp;&amp; _render();&#125;; &lt;ColorMap onChange=&#123;handleColorMapChange&#125; /&gt; 在项目中使用，以此记录一下","categories":[{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/categories/react/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"threejs","slug":"threejs","permalink":"http://zhuxiaohan.xyz/tags/threejs/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"}],"author":"Tispy Dr"},{"title":"药方","slug":"药方","date":"2022-07-06T05:46:00.000Z","updated":"2023-01-31T04:02:21.086Z","comments":true,"path":"2022/07/06/药方/","link":"","permalink":"http://zhuxiaohan.xyz/2022/07/06/%E8%8D%AF%E6%96%B9/","excerpt":"","text":"扁桃体发炎、咽炎 头孢呋辛酯片： 1片/次，2次/天 金银花颗粒：1包/次，3次/天","categories":[{"name":"药方","slug":"药方","permalink":"http://zhuxiaohan.xyz/categories/%E8%8D%AF%E6%96%B9/"}],"tags":[{"name":"药方","slug":"药方","permalink":"http://zhuxiaohan.xyz/tags/%E8%8D%AF%E6%96%B9/"}],"author":"Tispy Dr"},{"title":"播放帧的进度条组件的封装","slug":"播放帧的进度条组件的封装","date":"2022-06-29T03:00:00.000Z","updated":"2023-01-31T04:02:21.085Z","comments":true,"path":"2022/06/29/播放帧的进度条组件的封装/","link":"","permalink":"http://zhuxiaohan.xyz/2022/06/29/%E6%92%AD%E6%94%BE%E5%B8%A7%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"实现效果前边的一个一个的线是批量有效抽帧之后的效果 后边的绿色是全量有效的效果，然后红色为无效的效果 需求描述在需求中遇见了开发点云播放器的场景，对于播放器，不可避免的要有进度条的元素存在，然后我们的进度条还需要在进度条上设置有效无效的 tag 来用红色和绿色来显示 实现方案一第一个方案是：首先是一个 div 然后有onMouseDown，onMouseEnter两个事件，前者是为了点击进度条跳转，后者是为了鼠标悬浮在进度条是显示当前帧信息的，然后还有一个标度当前进度的点也是一个 dom 元素，利用监听当前帧来判断当前的位置并实时的改变，然后进度条上的帧的 tag 是直接插入了每帧的元素然后给了背景色来设置的，这样的一个问题就是，当帧的数据大于父元素的长度的时候就会出现挤压，然后当前帧 tag 的位置就会出现问题，而且插入的 dom 数量也着实有点多 方案二第二个方案是：和第一个方案不同的是创建了一个 canvas 标签来做我们的进度条，然后也是另一个单独的 dom 来标识当前的进度，然后在 tag 的部分做了处理是先判断当前有多少帧，然后根据 canvas 的长度以 3 像素每格计算出有多少个格子，然后帧和格子取小的，然后获取到每一格子有多少个宽，然后在 canvas 中绘制矩形的方式来绘制帧的 tag 的状态，有效为绿色无效为红色，矩形的宽为每格的宽，然后利用数据下标计算出格子的位置，用fillRect绘制图形 123456789101112131415161718192021const getFrames = (data: any[], dom: Element, targetDom: any) =&gt; &#123; if (!data || data.length &lt;= 0) return; const length = +data.length - 1; const &#123; width, height &#125; = dom.getBoundingClientRect(); // 计算有多少格子 let total = Math.floor(width / 3); total = total &lt; length ? total : length; const itemWidth = width / total; const ctx = targetDom.getContext(&#x27;2d&#x27;); ctx.canvas.width = width; ctx.canvas.height = height; if (targetDom) &#123; data.forEach((item, index) =&gt; &#123; ctx.fillStyle = +item?.status ? &#x27;#1f8736&#x27; : &#x27;#f70e0e&#x27;; ctx.fillRect((index / length) * (width - itemWidth), 0, itemWidth, 10); &#125;); &#125;&#125;; 完整代码为index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502import &#123; FC, useEffect, useState, useRef &#125; from &#x27;react&#x27;;import &#123; notice, CustomIcon, TipIcon &#125; from &#x27;@/components&#x27;;import &#123; Typography, Tag &#125; from &#x27;antd&#x27;;import &#123; ProgressWrapper, ProgressBar, ProgressLine, ProgressPoint, FrameInfo, Toolbar, Play, Speed, SpeedSelect,&#125; from &#x27;./styled&#x27;;import &#123; FrameBasicData &#125; from &#x27;@/types&#x27;;import moment from &#x27;moment&#x27;;import &#123; debounce, copyHandle &#125; from &#x27;@/utils&#x27;;const getFrames = (data: any[], dom: Element, targetDom: any) =&gt; &#123; if (!data || data.length &lt;= 0) return; const length = +data.length - 1; const &#123; width, height &#125; = dom.getBoundingClientRect(); // 计算有多少格子 let total = Math.floor(width / 3); total = total &lt; length ? total : length; const itemWidth = width / total; const ctx = targetDom.getContext(&#x27;2d&#x27;); ctx.canvas.width = width; ctx.canvas.height = height; if (targetDom) &#123; data.forEach((item, index) =&gt; &#123; ctx.fillStyle = +item?.status ? &#x27;#1f8736&#x27; : &#x27;#f70e0e&#x27;; ctx.fillRect((index / length) * (width - itemWidth), 0, itemWidth, 10); &#125;); &#125;&#125;;const debounceGetFrames = debounce(getFrames, 300);const &#123; Text &#125; = Typography;const speedList = [ &#123; label: 8 / 1, value: 1 / 8 &#125;, &#123; label: 4 / 1, value: 1 / 4 &#125;, &#123; label: 2 / 1, value: 1 / 2 &#125;, &#123; label: 3 / 2, value: 2 / 3 &#125;, &#123; label: 1 / 1, value: 1 / 1 &#125;, &#123; label: 1 / 2, value: 2 / 1 &#125;,];const getStatus = (status: string) =&gt; &#123; let dom = &lt;CustomIcon type=&quot;play&quot; /&gt;; switch (status) &#123; case &#x27;playing&#x27;: dom = &lt;CustomIcon type=&quot;pause&quot; /&gt;; break; case &#x27;pause&#x27;: dom = &lt;CustomIcon type=&quot;play&quot; /&gt;; break; case &#x27;replay&#x27;: dom = &lt;CustomIcon type=&quot;replay&quot; /&gt;; break; &#125; return dom;&#125;;interface Props &#123; current: number | string; preloadSize?: number; totalElements?: number | string; frameInfo?: FrameBasicData[]; frameInfoConfig?: &#123; key: string; label: string &#125;[]; onChange: (val: number) =&gt; void;&#125;const Progress: FC&lt;Props&gt; = (props) =&gt; &#123; const &#123; current, preloadSize = 20, frameInfo, totalElements, onChange, &#125; = props; const processRef: any = useRef(null); const line: any = useRef(null); const player: any = useRef(null); const [status, setStatus] = useState&lt; &#x27;pause&#x27; | &#x27;playing&#x27; | &#x27;replay&#x27; | &#x27;jumping&#x27; &gt;(&#x27;pause&#x27;); const [jump, setJump] = useState&lt;boolean&gt;(false); const [speed, setSpeed] = useState(&#123; label: 1, value: 1 &#125;); const [step, setStep] = useState&lt;number&gt;(0); const [count, setCount] = useState&lt;number&gt;(0); const [editSpeed, setEditSpeed] = useState&lt;boolean&gt;(false); const [isShowFrameInfo, setIsShowFrameInfo] = useState&lt;boolean&gt;(false); const [currentFrameInfo, setCurrentFrameInfo] = useState&lt;FrameBasicData&gt;(); const [frameInfoPosition, setFrameInfoPosition] = useState&lt;number&gt;(0); const [processLength, setProcessLength] = useState&lt;number | string&gt;(0); const debounceSetCurrentFrameInfo = debounce(setCurrentFrameInfo, 10); const next = () =&gt; &#123; if (step &gt; +current || +current - step &gt; preloadSize*2) &#123; pause(); notice(&#123; type: &#x27;warning&#x27;, mes: &#x27;正在加载中&#x27;, &#125;); return; &#125; if(!jump) &#123; setStep(step + 1); &#125; &#125;; const play = () =&gt; &#123; if (step === count - 1) &#123; pause(); setStatus(&#x27;replay&#x27;); return; &#125; player.current &amp;&amp; clearTimeout(player.current); const _player = setTimeout(() =&gt; &#123; next(); &#125;, 1000 * speed.value); player.current = _player; &#125;; const replay = () =&gt; &#123; setStep(0); play(); setStatus(&#x27;playing&#x27;); &#125;; const pause = () =&gt; &#123; player.current &amp;&amp; clearTimeout(player.current); player.current = null; setStatus(&#x27;pause&#x27;); &#125;; const isPlay = () =&gt; &#123; switch (status) &#123; case &#x27;replay&#x27;: replay(); return; case &#x27;playing&#x27;: pause(); return; case &#x27;pause&#x27;: setStatus(&#x27;playing&#x27;); play(); return; &#125; &#125;; const handleEditSpeed = (value: &#123; label: number; value: number &#125;) =&gt; &#123; setSpeed(value); setEditSpeed(false); if (status === &#x27;playing&#x27;) &#123; pause(); play(); setStatus(&#x27;playing&#x27;); &#125; &#125;; const getIndex = (e: any, jumpX?: string) =&gt; &#123; const length = jumpX ? jumpX : e.layerX || 0; const &#123; width &#125; = processRef.current.getBoundingClientRect(); let index = Math.floor((length / width) * count); if (index &gt;= count) &#123; index = count - 1; &#125; return index; &#125;; const jumpCount = (e: any, jumpX?: number) =&gt; &#123; if (count &lt;= 0) return; if (e.target.className.indexOf(&#x27;progressBar&#x27;) === -1) &#123; return; &#125; pause(); let index = getIndex(e, jumpX+&#x27;&#x27;); if(index&lt;0) &#123; index = 0 &#125; if (index &gt;= count) &#123; index = count - 1; &#125; setStep(index); if (index &gt;= current || +current - index &gt; preloadSize) &#123; notice(&#123; type: &#x27;warning&#x27;, mes: &#x27;正在加载中...&#x27;, &#125;); &#125; if (status === &#x27;pause&#x27; &amp;&amp; index === count - 1) &#123; setStatus(&#x27;replay&#x27;); &#125; return index &#125;; const movePoints = (e: any) =&gt; &#123; if (count &lt;= 0) return; if (e.target.className.indexOf(&#x27;progressBar&#x27;) === -1) &#123; return; &#125;; e.preventDefault(); const &#123; width &#125; = processRef.current.getBoundingClientRect(); const dom = document.getElementsByTagName(&#x27;body&#x27;)[0]; const &#123; pageX: startX &#125; = e; let x = 0 dom.onmousemove = function (ev: any) &#123; const &#123; pageX: nowX &#125; = ev; x = nowX - startX + e.layerX; if (x&lt;0) &#123; x = 0; &#125; else if (x &gt; width)&#123; x = width; &#125; setProcessLength(x); &#125;; dom.onmouseup = function (ev) &#123; setJump(true); dom.onmousemove = null; const &#123; pageX: nowX &#125; = ev; x = nowX - startX + e.layerX; if (x &lt; 0) &#123; x = 0; &#125; else if (x &gt; width) &#123; x = width; &#125; setProcessLength(x); const index = jumpCount(e, x); if (index&amp;&amp;Math.abs(index - count)&gt;preloadSize)&#123; window.stop(); &#125;; dom.onmouseup = null; setJump(false); &#125;; &#125;; const gotoStep = (num: number) =&gt; &#123; if( count&lt;= 0 ) return; let _count = step + num; if(_count &lt; count - 1 &amp;&amp; status === &#x27;replay&#x27;) &#123; setStatus(&#x27;pause&#x27;); &#125; else if(_count &gt;= count - 1 &amp;&amp; status === &#x27;pause&#x27;) &#123; setStatus(&#x27;replay&#x27;); &#125; if (_count &gt; count - 1) &#123; _count = count - 1; &#125; if (_count &lt; 0) &#123; _count = 0; &#125; setStep(_count); &#125;; const getFrameInfoPosition = (e: any) =&gt; &#123; e.preventDefault(); const &#123; frameInfo, frameInfoConfig &#125; = props; if (!frameInfoConfig || frameInfoConfig.length &lt; 0) &#123; return; &#125; const &#123; width &#125; = processRef.current.getBoundingClientRect(); const max = width - 50; const min = 0 - 50; let x = 0; const &#123; pageX: startX &#125; = e; const dom = e.target; const lineOffsetLeft = e.target.offsetLeft; if (e.nativeEvent.layerX - lineOffsetLeft &lt; min) &#123; setFrameInfoPosition(0); &#125; else if (e.nativeEvent.layerX - lineOffsetLeft &gt; max) &#123; setFrameInfoPosition(max); &#125; setIsShowFrameInfo(true); dom.onmousemove = function (ev: any) &#123; const &#123; pageX: nowX &#125; = ev; x = nowX - startX + e.nativeEvent.layerX - lineOffsetLeft - 50; if (x &lt; min) &#123; x = min; &#125; else if (x &gt; max) &#123; x = max; &#125; else &#123; setFrameInfoPosition(x); &#125; let currentFrameInfo = &#123;&#125;; const index = getIndex(e, x + 50 + &#x27;&#x27;) if (frameInfo) &#123; currentFrameInfo = &#123; ...frameInfo[index], index: index &#125;; &#125;else &#123; currentFrameInfo = &#123; index: index &#125;; &#125; debounceSetCurrentFrameInfo(currentFrameInfo); &#125;; dom.onmouseleave = function (ev: any) &#123; dom.onmousemove = null; const &#123; pageX: nowX &#125; = ev; x = nowX - startX + e.layerX - lineOffsetLeft; if (x &lt; min) &#123; x = 0; &#125; else if (x &gt; max) &#123; x = max; &#125; else &#123; setFrameInfoPosition(x); &#125; dom.onmouseleave = null; setIsShowFrameInfo(false); &#125;; &#125;; const keyboard = (ev: KeyboardEvent) =&gt; &#123; switch (ev.key || String.fromCharCode(ev.keyCode || ev.charCode)) &#123; case &#x27;a&#x27;: gotoStep(-1); break; case &#x27;d&#x27;: gotoStep(1); break; &#125; &#125;; const resize = () =&gt; &#123; debounceGetFrames(frameInfo, processRef.current, line.current); &#125;; useEffect(() =&gt; &#123; Promise.resolve().then(() =&gt; &#123; const &#123; width &#125; = processRef.current.getBoundingClientRect(); if (status === &#x27;playing&#x27;) &#123; play(); &#125; if (!jump) &#123; setProcessLength((step / (count - 1)) * width); &#125; onChange(step); &#125;); &#125;, [step]); useEffect(() =&gt; &#123; window.addEventListener(&#x27;resize&#x27;, resize); return () =&gt; &#123; window.removeEventListener(&#x27;resize&#x27;, resize); &#125;; &#125;); useEffect(() =&gt; &#123; window.addEventListener(&#x27;keypress&#x27;, keyboard); return () =&gt; &#123; window.removeEventListener(&#x27;keypress&#x27;, keyboard); &#125;; &#125;); useEffect(() =&gt; &#123; resize(); setCount( (frameInfo &amp;&amp; frameInfo.length) || (totalElements &amp;&amp; +totalElements) || 0, ); &#125;, [frameInfo, totalElements]); return ( &lt;ProgressWrapper&gt; &lt;Toolbar&gt; &lt;TipIcon tipProps=&#123;&#123; title: step &lt;= 0 ? &#x27;没有了哦！&#x27; : &#x27;往后 10 帧&#x27;, &#125;&#125; type=&quot;fb&quot; onClick=&#123;() =&gt; gotoStep(-10)&#125; /&gt; &lt;TipIcon tipProps=&#123;&#123; title: step &lt;= 0 ? &#x27;没有了哦！&#x27; : &#x27;往后 1 帧&#x27;, &#125;&#125; type=&quot;retreat&quot; onClick=&#123;() =&gt; gotoStep(-1)&#125; /&gt; &lt;Play style=&#123;&#123; margin: &#x27;0 8px 0 10px&#x27; &#125;&#125; onClick=&#123;isPlay&#125;&gt; &#123;getStatus(status)&#125; &lt;/Play&gt; &lt;TipIcon tipProps=&#123;&#123; title: step &gt;= count - 1 ? &#x27;没有了哦！&#x27; : &#x27;往前 1 帧&#x27;, &#125;&#125; type=&quot;forward&quot; onClick=&#123;() =&gt; gotoStep(1)&#125; /&gt; &lt;TipIcon tipProps=&#123;&#123; title: step &gt;= count - 1 ? &#x27;没有了哦！&#x27; : &#x27;往前 10 帧&#x27;, &#125;&#125; type=&quot;ff&quot; onClick=&#123;() =&gt; gotoStep(10)&#125; /&gt; &lt;Speed onMouseOver=&#123;() =&gt; setEditSpeed(true)&#125; onMouseLeave=&#123;() =&gt; setEditSpeed(false)&#125; &gt; &lt;span&gt;&#123;speed.label&#125;&lt;/span&gt; &lt;CustomIcon type=&quot;x&quot; /&gt; &#123;editSpeed ? ( &lt;SpeedSelect onMouseEnter=&#123;() =&gt; setEditSpeed(true)&#125; onMouseLeave=&#123;() =&gt; setEditSpeed(false)&#125; &gt; &#123;speedList.map(item =&gt; &#123; return ( &lt;div key=&#123;item.value&#125; onClick=&#123;() =&gt; &#123; handleEditSpeed(item); &#125;&#125; &gt; &lt;span&gt;&#123;item.label&#125;&lt;/span&gt; &lt;CustomIcon type=&quot;x&quot; color=&quot;#fff&quot; /&gt; &lt;/div&gt; ); &#125;)&#125; &lt;/SpeedSelect&gt; ) : ( &#x27;&#x27; )&#125; &lt;/Speed&gt; &lt;/Toolbar&gt; &lt;ProgressBar className=&quot;progressBar&quot; ref=&#123;processRef&#125; onMouseDown=&#123;() =&gt; movePoints(event)&#125; onMouseEnter=&#123;e =&gt; getFrameInfoPosition(e)&#125; &gt; &lt;ProgressLine ref=&#123;line&#125; /&gt; &lt;ProgressPoint style=&#123;&#123; left: `$&#123;+processLength&#125;px` &#125;&#125; /&gt; &#123;isShowFrameInfo ? ( &lt;FrameInfo style=&#123;&#123; left: `$&#123;+frameInfoPosition&#125;px` &#125;&#125;&gt; &#123;props?.frameInfoConfig?.map(item =&gt; &#123; const info: any = currentFrameInfo; let value = currentFrameInfo &amp;&amp; info[item.key]; if (item.key === &#x27;smallestUnitTimestamp&#x27;) &#123; value = ( &lt;a&gt; &#123;moment( currentFrameInfo &amp;&amp; info[item.key] / 1000000, ).format(&#x27;HH:mm:ss&#x27;)&#125; &lt;/a&gt; ); &#125; else if (item.key === &#x27;status&#x27;) &#123; value = ( &lt;Tag color=&#123; currentFrameInfo &amp;&amp; +info[item.key] ? &#x27;success&#x27; : &#x27;error&#x27; &#125; &gt; &#123;currentFrameInfo &amp;&amp; +info[item.key] === 1 ? &#x27;有效&#x27; : &#x27;无效&#x27;&#125; &lt;/Tag&gt; ); &#125; return ( &lt;Text key=&#123;item.key&#125; ellipsis=&#123;&#123; tooltip: value &#125;&#125; onClick=&#123;() =&gt; &#123; if (item.key !== &#x27;smallestUnitTimestamp&#x27;)&#123; return; &#125; copyHandle(currentFrameInfo &amp;&amp; info[item.key]); notice(&#123; type: &#x27;info&#x27;, mes: &#x27;复制当前帧时间&#x27; &#125;); &#125;&#125; &gt; &#123;`$&#123;item.label&#125;: `&#125; &#123;value&#125; &lt;/Text&gt; ); &#125;)&#125; &lt;/FrameInfo&gt; ) : null&#125; &lt;/ProgressBar&gt; &lt;span&gt; &#123;(frameInfo &amp;&amp; frameInfo[frameInfo?.length - 1]?.smallestUnitTimestamp &amp;&amp; moment( +frameInfo[frameInfo?.length - 1]?.smallestUnitTimestamp! / 1000000, ).format(&#x27;HH:mm:ss&#x27;))&#125; &lt;/span&gt; &lt;/ProgressWrapper&gt; );&#125;;export default Progress; styled.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import styled from &#x27;styled-components&#x27;;export const ProgressWrapper = styled.div` position: relative; z-index: 999999; width: 100%; height: 20px; border-radius: 10px; display: flex; align-items: center; background: #ffffffa6;`;interface ProgressPointProps &#123; left?: number | string; width?: number | string; background?: number | string;&#125;export const ProgressBar = styled.div` position: relative; margin: 10px 0; width: 100%; height: 10px; opacity: .7; cursor: pointer;`;export const FrameInfo = styled.div` display: flex; justify-content: space-around; flex-direction: column; position: absolute; left: $&#123;(props: ProgressPointProps) =&gt; props.left || 0&#125;; bottom: 10px; padding: 10px 4px; width: 100px; height: 100px; font-size: 12px; border-radius: 10px; background-color: #fff;`;export const ProgressLine = styled.canvas` pointer-events: none; width: 100%; margin: 10px 0; position: absolute; top: -10px; height: 10px; background-color: #ccc; cursor: pointer;`;export const ProgressPoint = styled.div` pointer-events: none; position: absolute; left: $&#123;(props: ProgressPointProps) =&gt; props.left || 0&#125;; top: -5px; z-index: 1; opacity: 0.6; width: 1px; height: 20px; background-color: #7e16cd; border: 1px solid #7e16cd;`;export const Toolbar = styled.div` display: flex; align-items: center; justify-content: center; margin-right: 10px; height: 20px;`;export const Speed = styled.div` position: relative; display: flex; align-items: center; justify-content: center; margin-left: 10px; width: 40px; height: 20px; cursor: pointer;`;export const SpeedSelect = styled.div` position: absolute; z-index: 1; bottom: 20px; right: 0px; text-align: center; background: #000; color: #fff; &amp; &gt; div &#123; display: flex; align-items: center; justify-content: center; padding: 4px 0; :hover &#123; background-color: #ffffff5a; &#125; &#125;`;export const Play = styled.div` margin-left: -3px; height: 20px; cursor: pointer;`;","categories":[{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/categories/react/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"},{"name":"组件","slug":"组件","permalink":"http://zhuxiaohan.xyz/tags/%E7%BB%84%E4%BB%B6/"}],"author":"Tispy Dr"},{"title":"Threejs 播放点云的预加载方案","slug":"Threejs-播放点云的预加载方案","date":"2022-06-29T02:26:00.000Z","updated":"2023-01-31T04:02:21.079Z","comments":true,"path":"2022/06/29/Threejs-播放点云的预加载方案/","link":"","permalink":"http://zhuxiaohan.xyz/2022/06/29/Threejs-%E6%92%AD%E6%94%BE%E7%82%B9%E4%BA%91%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/","excerpt":"","text":"最近工作上边做数据管理平台，需要播放图片和点云，我们播放的形式和传统的视频流有些区别是点云播放的是一帧一帧的 pcd 文件，图片是一帧一帧的 jpg 文件，而我们的点云文件平均大小是 1.5M 每个，图片文件是平均 230 kb 每个，所以问题就来了，自我们公司平均不足 1M/s 的下载速度下我们的播放就受到了很大的限制，所以我们也不得不做预加载和懒加载的功能 懒加载的实现懒加载的实现就是一个占位图，占位图是用 three 的平面模型和图片纹理渲染一个加载中或者数据为空的图片，然后每次加载 pcd文件还未成功的时候先绘制 loadImage 的 object3D 对象，其代码如下： 12345678const loadImage = async (url: string) =&gt; &#123; new THREE.TextureLoader().load(url, (texture: THREE.Texture) =&gt; &#123; const mat = new THREE.SpriteMaterial(&#123; map: texture, color: 0xffffff &#125;); const obj = new THREE.Sprite(mat); obj.geometry.scale(10, 10, 10); _lazyObj = obj; &#125;);&#125;; 预加载的实现预加载预加载的实现，中间想了多种方式，一种是利用空闲时间持续往一个变量里边 push，然我们的帧的数据量都是以万记的，所以为了节省内存不得不放弃这种方式，采用分页的形式使用预加载，每次的时候我们会提前加载下一页的数据，然后再到下一页的时候继续加载下一页，然后把之前预加载的赋值给当前变量，但是这个方案在后边 我自己 review 代码的时候发现了另一个问题，即当我播放的速度太快，而变量的赋值比页面重新渲染的速度慢或者还没赋值成功的时候，会出现挑帧用的还是替换之前的数据的情况，如果加 loading 的话就会有明显的卡顿，这样预加载的意义会就不大了，所以后边我就用了采用奇数偶数的形式，偶数为下一页用预加载的数据，基数为第一页这种的除了第一页也是也加载的这样来回切换，然后问题就能得到比较好的解决。 1234567891011121314151617181920212223242526272829303132333435363738394041useEffect(() =&gt; &#123; getFrameList();&#125;, [resultId, pageNumber, preloadSize, dataType]);useEffect(() =&gt; &#123; getNextFrameList();&#125;, [resultId, nextPageNumber, preloadSize, dataType]);useEffect(() =&gt; &#123; const consult = Math.floor((step + 1) / preloadSize); const remainder = (step + 1) % preloadSize; let nowPageNumber = consult; if (remainder &gt; 0) &#123; nowPageNumber = consult + 1; &#125; console.log(step + 1, pageNumber, nextPageNumber, nowPageNumber); if (nowPageNumber &gt;= totalPages) &#123; return; &#125; else if (nowPageNumber &lt; pageNumber &amp;&amp; nowPageNumber &lt; nextPageNumber) &#123; if (nowPageNumber % 2 === 0) &#123; setNextPageNumber(nowPageNumber); &#125; else &#123; setPageNumber(nowPageNumber); &#125; &#125; else if (nowPageNumber &gt; pageNumber &amp;&amp; nowPageNumber &gt; nextPageNumber) &#123; if (nowPageNumber % 2 === 0) &#123; setNextPageNumber(nowPageNumber); &#125; else &#123; setPageNumber(nowPageNumber); &#125; &#125; else if (nowPageNumber % 2 === 0) &#123; setPageNumber(nowPageNumber + 1); &#125; else &#123; setNextPageNumber(nowPageNumber + 1); &#125; setSearchParams(&#123; resultId: resultId, batchStatus: batchStatus + &#x27;&#x27;, key: key, &#125;);&#125;, [step]); 123456789101112131415161718192021222324252627282930useEffect(() =&gt; &#123; _renderer &amp;&amp; _frameList?.content &amp;&amp; _frameList?.content.length &amp;&amp; getPointsTask(_frameList?.content, &#x27;current&#x27;);&#125;, [_frameList]);useEffect(() =&gt; &#123; const pageNumber = Math.floor((step + 1) / preloadSize); if (totalPages &amp;&amp; +pageNumber === +totalPages) return; _renderer &amp;&amp; _nextFrameList?.content &amp;&amp; _nextFrameList?.content?.length &amp;&amp; getPointsTask(_nextFrameList?.content, &#x27;next&#x27;);&#125;, [_nextFrameList]);useEffect(() =&gt; &#123; const pageNumber = Math.floor(step / preloadSize) + 1; const pointsIndex = step % preloadSize; const list = pageNumber % 2 === 0 ? _nextFrameList : _frameList; if (list?.content &amp;&amp; list?.content[pointsIndex] &amp;&amp; _render) &#123; getPoints(list?.content[pointsIndex]?.pcdOssAddress!); setLoading(false); &#125; else &#123; setLoading(true); &#125;&#125;, [step, _frameList, _nextFrameList]); 进度条跳转中断接口的方式进度条跳转有可能会持续请求上一次的预加载，中断请求的方式粗暴的使用了 1window.stop();","categories":[],"tags":[{"name":"点云","slug":"点云","permalink":"http://zhuxiaohan.xyz/tags/%E7%82%B9%E4%BA%91/"},{"name":"threejs","slug":"threejs","permalink":"http://zhuxiaohan.xyz/tags/threejs/"},{"name":"预加载","slug":"预加载","permalink":"http://zhuxiaohan.xyz/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/"}],"author":"Tispy Dr"},{"title":"写个 CLI Demo 吧","slug":"写个-CLI-Demo-吧","date":"2022-04-27T10:13:00.000Z","updated":"2023-01-31T04:02:21.083Z","comments":true,"path":"2022/04/27/写个-CLI-Demo-吧/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/27/%E5%86%99%E4%B8%AA-CLI-Demo-%E5%90%A7/","excerpt":"","text":"CLI Demo","categories":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"node","permalink":"http://zhuxiaohan.xyz/tags/node/"}],"author":"Tispy Dr"},{"title":"关于技术上 一些想做的事儿 和 设想","slug":"Untitled","date":"2022-04-25T02:38:00.000Z","updated":"2023-01-31T04:02:21.079Z","comments":true,"path":"2022/04/25/Untitled/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/25/Untitled/","excerpt":"","text":"组件及页面管理系统希望有个组件管理系统，提供以组件为焦点的管理，对于页面维度，可以进行组件的添加、卸载、配置以及重新生成和部署对于组件可进行编辑、生成以及部署","categories":[{"name":"feature","slug":"feature","permalink":"http://zhuxiaohan.xyz/categories/feature/"}],"tags":[{"name":"feature","slug":"feature","permalink":"http://zhuxiaohan.xyz/tags/feature/"},{"name":"项目","slug":"项目","permalink":"http://zhuxiaohan.xyz/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"设想","slug":"设想","permalink":"http://zhuxiaohan.xyz/tags/%E8%AE%BE%E6%83%B3/"}],"author":"Tispy Dr"},{"title":"命令行输入git branch，发现进入编辑状态","slug":"命令行输入git-branch，发现进入编辑状态","date":"2022-04-21T07:26:00.000Z","updated":"2023-01-31T04:02:21.084Z","comments":true,"path":"2022/04/21/命令行输入git-branch，发现进入编辑状态/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5git-branch%EF%BC%8C%E5%8F%91%E7%8E%B0%E8%BF%9B%E5%85%A5%E7%BC%96%E8%BE%91%E7%8A%B6%E6%80%81/","excerpt":"","text":"问题在配置iterm2的时候，之后再次用命令行输入git branch的时候 发现老是进入编辑状态，退出的时候都要按q键，非常的不方便！ 解决办法：在终端输入 这行命令即可：git config –global core.pager ‘’","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"http://zhuxiaohan.xyz/tags/mac/"}],"author":"Tispy Dr"},{"title":"mac 通过使用alias简化git命令输入","slug":"mac-通过使用alias简化git命令输入","date":"2022-04-21T07:22:00.000Z","updated":"2023-01-31T04:02:21.082Z","comments":true,"path":"2022/04/21/mac-通过使用alias简化git命令输入/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/mac-%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8alias%E7%AE%80%E5%8C%96git%E5%91%BD%E4%BB%A4%E8%BE%93%E5%85%A5/","excerpt":"","text":"命令1234567891011121314151617181920212223alias gs=&#x27;git s&#x27;alias gst=&#x27;git status&#x27;alias ga=&#x27;git add -A .&#x27;alias gc=&#x27;git commit -m&#x27;alias gd=&#x27;git diff&#x27;alias gdicdiff=&#x27;git icdiff&#x27;alias gdopendiff=&#x27;git difftool --tool=opendiff&#x27;alias gl=&#x27;git log -3&#x27;alias gls=&#x27;git log -3 --name-status&#x27;alias gp=&#x27;git pull --rebase&#x27;alias gb=&#x27;git branch&#x27;alias gbs=&#x27;git branches&#x27;alias cdm=&#x27;cd ~/Documents/mine&#x27;alias cdw=&#x27;cd ~/Documents/work&#x27;alias cdmrd=&#x27;cd ~/Documents/work/mrd&#x27;alias cdd=&#x27;cd ~/Documents/work/directory&#x27;alias cdmd=&#x27;cd ~/Documents/mine/directory&#x27;alias gcl=&#x27;git clone&#x27;alias gpush=&#x27;git push&#x27;alias nrs=&#x27;npm run serve&#x27;alias ns=&#x27;npm run start&#x27;alias nd=&#x27;npm run dev&#x27;alias ddnm=&#x27;rm -r package-lock.json &amp; rm -r node_modules&#x27; 使用 item2 问题设置别名的时候, 是去修改用户目录下的 .bashrc 或者 .bash_profile 这两个文件都可以, 把 alias 写在这两个文件里面, 别名就会永久生效. 但是使用 Item2 终端的时候会不生效 是因为 使用 item2 并使用 .zsh 来设置主题，且 .zshrc 执行的是 .bash_profile可以将别名 alias 就需要设置 在用户目录下的 .zshrc 中解决 1vi ~/.zshrc 或者在 .bash_profile 中加入 12# setting aliassource ~/.bashrc","categories":[],"tags":[],"author":"Tispy Dr"},{"title":"一些前端常用的工具函数","slug":"一些前端常用的工具函数","date":"2022-04-21T07:11:00.000Z","updated":"2023-01-31T04:02:21.082Z","comments":true,"path":"2022/04/21/一些前端常用的工具函数/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"这个用来总结前端一些常用的工具函数 获取url里边的参数12345678910111213const getQueryVariable = (variable: string) =&gt; &#123; const query = window.location.search.substring(1); const vars = query.split(&#x27;&amp;&#x27;); for (const item of vars) &#123; const pair = item.split(&#x27;=&#x27;); if (pair[0] === variable) &#123; return pair[1]; &#125; &#125; return null;&#125;;getQueryVariable(&quot;id&quot;); 类似于loash.js的get函数1234567891011121314const get = (source: any, path: string, defaultValue: any) =&gt; &#123; const paths = path.replace(/\\[(\\d+)\\]/g, &#x27;.$1&#x27;).split(&#x27;.&#x27;); let result = source; for (const p of paths) &#123; result = Object(result)[p]; if (result === undefined) &#123; return defaultValue; &#125; &#125; return result;&#125;;# 第一个参数是需要查找的对象，第二个参数是需要查找的key，最后一参数是如果没找到返回的默认值get(object,object.name,0); 降秒格式化为时分秒12345678910111213141516171819202122232425export function formatSeconds(val: number | string | undefined): string &#123; if (typeof val === &#x27;undefined&#x27;) &#123; return &#x27;0秒&#x27;; &#125; let result: number = Number.isNaN(val) ? parseInt(val + &#x27;&#x27;) : +val!; let h = Math.floor(result / 3600) &lt; 10 ? &#x27;0&#x27; + Math.floor(result / 3600) : Math.floor(result / 3600); let m = Math.floor((result / 60) % 60) &lt; 10 ? &#x27;0&#x27; + Math.floor((result / 60) % 60) : Math.floor((result / 60) % 60); let s = Math.floor(result % 60) &lt; 10 ? &#x27;0&#x27; + Math.floor(result % 60) : Math.floor(result % 60); let res = &#x27;&#x27;; if (h !== &#x27;00&#x27;) res += `$&#123;h&#125;小时`; if (m !== &#x27;00&#x27;) res += `$&#123;m&#125;分钟`; res += `$&#123;s&#125;秒`; return res;&#125; 通过 url 下载文件123456export async function downloadRes(url: string) &#123; let a = document.createElement(&#x27;a&#x27;); a.href = url; a.click(); a.remove();&#125; 添加内容至剪切板（复制）1234567891011121314export function copyHandle(content: string) &#123; const clip = &#123; status: false, &#125;; let copy = (e: any) =&gt; &#123; e.preventDefault(); e.clipboardData.setData(&#x27;text/plain&#x27;, content); clip.status = true; document.removeEventListener(&#x27;copy&#x27;, copy); &#125;; document.addEventListener(&#x27;copy&#x27;, copy); document.execCommand(&#x27;Copy&#x27;); return clip;&#125; 待添加1","categories":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Tispy Dr"},{"title":"js 获取音视频文件的时长","slug":"js-获取音视频文件的时长","date":"2022-04-21T07:09:00.000Z","updated":"2023-01-31T04:02:21.081Z","comments":true,"path":"2022/04/21/js-获取音视频文件的时长/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/js-%E8%8E%B7%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%95%BF/","excerpt":"","text":"1234567891011121314function getTimes() &#123; var obj_file = document.getElementById(&quot;upload&quot;); var content = obj_file.files[0] //获取时长 var url = URL.createObjectURL(content) var audioElement = new Audio(url); var duration; audioElement.addEventListener(&quot;loadedmetadata&quot;, function (_event) &#123; duration = audioElement.duration; console.log(duration/60); &#125;);&#125;","categories":[],"tags":[],"author":"Tispy Dr"},{"title":"js 上传腾讯云，更新视频时长","slug":"js上传腾讯云，更新视频时长","date":"2022-04-21T07:05:00.000Z","updated":"2023-01-31T04:02:21.081Z","comments":true,"path":"2022/04/21/js上传腾讯云，更新视频时长/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/js%E4%B8%8A%E4%BC%A0%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF/","excerpt":"","text":"123456onProgress: function(data) &#123; var percent = parseInt(data.percent * 10000) / 100; data.percent = percent; option.onProgress(data);&#125;","categories":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"}],"author":"Tispy Dr"},{"title":"推荐文章 第一期","slug":"推荐文章-第一期","date":"2022-04-21T06:51:00.000Z","updated":"2023-01-31T04:02:21.084Z","comments":true,"path":"2022/04/21/推荐文章-第一期/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0-%E7%AC%AC%E4%B8%80%E6%9C%9F/","excerpt":"","text":"推荐文章 网络文章 网页骨架屏自动生成方案（dps）网页骨架屏自动生成方案（dps） 推荐理由：本文详细介绍了前端骨架屏生成的几种方案，以及优缺点，然后给出了一个相对合理的解决方案，感兴趣的可以了解下 SSR 与当年的 JSP、PHP 有什么区别及前端渲染模式SSR 与当年的 JSP、PHP 有什么区别及前端渲染模式 推荐理由：简要介绍下SSR的前世今生以及前端渲染模式的探索 如何更好地理解中间件和洋葱模型如何更好地理解中间件和洋葱模型 推荐理由：介绍了中间件的概念，详细解释了koa的洋葱圈模型及其compose函数的实现方法 微前端实践微前端实践 推荐理由：以qiankun框架为例讲解微服务的实践，有助于了解微服务概念 图片加载失败后CSS样式处理最佳实践图片加载失败后CSS样式处理最佳实践 推荐理由：图片加载失败的兜底处理 温故知新：前端安全知多少前端安全知多少 推荐理由：常见的前端安全问题以及对应的解决方案；一丢丢网络攻击的小技巧和小知识；一些经典的漏洞攻击案例；以及最近进入我们视野的新的攻击手段； vue中需要注意的问题总结vue中需要注意的问题总结 推荐理由：vue开发中可能会遇到的一些问题，一些需要注意的点。例如keep-alive,生命周期等。 精读《如何做好 CodeReview》精读《如何做好 CodeReview》 推荐理由：CodeReview 的覆盖范围，语气，跨办公区、时区等情况的 code review 该怎么做。 JavaScript ES12 新特性抢先体验JavaScript ES12 新特性抢先体验 推荐理由：JavaScript ES12 新特性，对String.prototype.replaceAll 新增replaceAll、Promise.any、WeakRefs、逻辑运算符和赋值表达式、数字分隔符号的讲解","categories":[{"name":"推荐文章","slug":"推荐文章","permalink":"http://zhuxiaohan.xyz/categories/%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"推荐文章","slug":"推荐文章","permalink":"http://zhuxiaohan.xyz/tags/%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/"}],"author":"Tispy Dr"},{"title":"基于 SparkMD5 获取文件的md5值","slug":"基于-speackMd5-获取文件的md5值","date":"2022-04-21T06:47:00.000Z","updated":"2023-01-31T04:02:21.084Z","comments":true,"path":"2022/04/21/基于-speackMd5-获取文件的md5值/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/%E5%9F%BA%E4%BA%8E-speackMd5-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84md5%E5%80%BC/","excerpt":"","text":"创建工具函数123456789101112131415161718192021222324import SparkMD5 from &#x27;spark-md5&#x27;;export function createFileMd5(file: any) &#123; // const spark = new SparkMD5(); return new Promise((resolve, reject) =&gt; &#123; const fileReader = new FileReader(); // 开始读文件 fileReader.readAsBinaryString(file); // 文件读完之后，触发load事件 fileReader.onload = (e: any) =&gt; &#123; // result是fileReader读到的部分 const result = e.target.result; // 如果读到的长度和文件长度一致，则读取成功 const isSuccess = file.size === result.length; // 读取成功，则生成MD5，扔出去。失败就报错 isSuccess ? resolve(SparkMD5.hashBinary(result)) : reject(new Error(&#x27;读取出错了&#x27;)); &#125;; // 读取过程中出错也直接报错 fileReader.onerror = () =&gt; reject(new Error(&#x27;读取出错了&#x27;)); &#125;);&#125; 使用1234import &#123; createFileMd5 &#125; from &#x27;@/utils/get-files-md5&#x27;;createFileMd5(file.raw).then((md5) =&gt; &#123; console.log(md5)&#125;);","categories":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"MD5","slug":"MD5","permalink":"http://zhuxiaohan.xyz/tags/MD5/"}],"author":"Tispy Dr"},{"title":"elementUi table表格添加拖拽功能","slug":"elementUi-table表格的拖拽功能","date":"2022-04-21T06:39:00.000Z","updated":"2023-01-31T04:02:21.080Z","comments":true,"path":"2022/04/21/elementUi-table表格的拖拽功能/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/elementUi-table%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/","excerpt":"","text":"基于 element ui 的 Table 组件 和 Sortable 为表格添加拖拽功能 引入插件1import Sortable from &#x27;sortablejs&#x27;; 添加声明1sortable: any = null; 初始化12345678910111213141516171819202122mounted() &#123; const targetDom = this.$refs.table; this.sortable = new Sortable(targetDom, &#123; onEnd: this.onEnd &#125;);&#125;@Emit(&#x27;drap&#x27;)onEnd(&#123; oldIndex, newIndex &#125;) &#123; return &#123; oldIndex: oldIndex, newIndex: newIndex &#125;;&#125; 逻辑处理代码：handleDrap(index, key) &#123; const currRow = this.data[key].splice(index.oldIndex, 1)[0]; this.data[key].splice(index.newIndex, 0, currRow);&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://zhuxiaohan.xyz/categories/vue/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://zhuxiaohan.xyz/tags/vue/"},{"name":"拖拽","slug":"拖拽","permalink":"http://zhuxiaohan.xyz/tags/%E6%8B%96%E6%8B%BD/"}],"author":"Tispy Dr"},{"title":"elementUI上传图片前判断图片的尺寸大小","slug":"elementUI上传图片前判断图片的尺寸大小","date":"2022-04-21T06:35:00.000Z","updated":"2023-01-31T04:02:21.080Z","comments":true,"path":"2022/04/21/elementUI上传图片前判断图片的尺寸大小/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/elementUI%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%89%8D%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E7%9A%84%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"1234567891011121314151617181920beforeAvatarUpload(file) &#123; const isSize = new Promise(function(resolve, reject) &#123; let width = 100; let height = 100; let _URL = window.URL || window.webkitURL; let img = new Image(); img.onload = function() &#123; let valid = img.width &gt;= width &amp;&amp; img.height &gt;= height; valid ? resolve() : reject(); &#125; img.src = _URL.createObjectURL(file); &#125;).then(() =&gt; &#123; return file; &#125;, () =&gt; &#123; this.$message.error(&#x27;上传的icon必须是等于或大于100*100!&#x27;); return Promise.reject(); &#125;); return isSize;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"}],"author":"Tispy Dr"},{"title":"防抖和节流","slug":"防抖和节流","date":"2022-04-21T06:24:00.000Z","updated":"2023-01-31T04:02:21.087Z","comments":true,"path":"2022/04/21/防抖和节流/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/21/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖123456789101112131415161718/** * 防抖 * * @param &#123;*&#125; f * @param &#123;*&#125; wait * @return &#123;*&#125; */function debounce(f, wait) &#123; let timer = null; return (...args) =&gt; &#123; if(timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; f(...args); &#125;, wait); &#125;&#125; 节流非首次执行12345678910111213141516171819/** * 节流 非首次执行 * * @param &#123;*&#125; f * @param &#123;*&#125; wait * @return &#123;*&#125; */function throttle(f, wait) &#123; let timer = null; return (...args) =&gt; &#123; if(timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; f(...args); timer = null; &#125;, wait); &#125;&#125; 节流1234567891011121314151617/** * 节流 首次执行 * * @param &#123;*&#125; f * @param &#123;*&#125; wait * @return &#123;*&#125; */function throttle(f, wait) &#123; let last = 0; return (...args) =&gt; &#123; const now = Date.now(); if(now - last &gt;= wait) &#123; f(...args); last = now; &#125; &#125;&#125; 节流 两者结合12345678910111213141516171819202122232425262728293031/** * 节流 两者结合 * * @param &#123;*&#125; f * @param &#123;*&#125; wait * @return &#123;*&#125; */function throttle(f, wait) &#123; let last = 0; let timer = null; return (...args) =&gt; &#123; const now = Date.now(); const remaining = wait - (now - last); clearTimeout(timer) if(remaining &lt;= 0) &#123; f(...args); last = Date.now(); &#125; else &#123; if(timer) return; timer = setInterval(() =&gt; &#123; f(...args); last = Date.now(); &#125;, remaining); &#125; &#125;&#125; 测试12345678910111213141516171819function sayHellow() &#123; console.log(&#x27;hellow&#x27;);&#125; // const debounceSayHellow = debounce(sayHellow, 2000); // debounceSayHellow();// debounceSayHellow();// debounceSayHellow();// debounceSayHellow();// debounceSayHellow();// debounceSayHellow(); const throttleSayHellow = throttle(sayHellow, 2000); setInterval(() =&gt; &#123; throttleSayHellow();&#125;, 500);","categories":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"防抖 节流","slug":"防抖-节流","permalink":"http://zhuxiaohan.xyz/tags/%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/"},{"name":"面试题","slug":"面试题","permalink":"http://zhuxiaohan.xyz/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"author":"Tispy Dr"},{"title":"git设置用户名和邮箱","slug":"git","date":"2022-04-14T06:47:00.000Z","updated":"2023-01-31T04:02:21.081Z","comments":true,"path":"2022/04/14/git/","link":"","permalink":"http://zhuxiaohan.xyz/2022/04/14/git/","excerpt":"","text":"git设置用户名和邮箱1.设置用户名和密码 git config –global user.name “username” git config –global user.email &#117;&#x73;&#101;&#x72;&#101;&#x6d;&#97;&#105;&#x6c;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#109; –注意邮箱没有双引号 2.查看用户名和密码 git config user.name git config user.email 3.创建一个新的存储库 git clone https://giturl/user.name/projectname.gitcd testprojecttouch README.mdgit add README.mdgit commit -m “add README”git push -u origin master 第一次创建存储库,输入上面第一个命令有可能会出现remote: HTTP Basic: Access denied报错,主要原因是首次输入的用户名或密码不正确，导致上传时验证失败，所以要重新设置，如下git config –system –unset credential.helper SSH配置1、打开git bash 2、执行生成公钥和私钥的命令：ssh-keygen -t rsa 并按回车3下（为什么按三下，是因为有提示你是否需要设置密码，如果设置了每次使用Git都会用到密码，一般都是直接不写为空，直接回车就好了）。会在一个文件夹里面生成一个私钥 id_rsa和一个公钥id_rsa.pub。（可执行start ~ 命令，生成的公私钥在 .ssh的文件夹里面） 3、执行查看公钥的命令：cat ~/.ssh/id_rsa.pub","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://zhuxiaohan.xyz/tags/git/"}],"author":"Tispy Dr"},{"title":"分片上传","slug":"分片上传","date":"2022-03-29T11:10:00.000Z","updated":"2023-01-31T04:02:21.083Z","comments":true,"path":"2022/03/29/分片上传/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/29/%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219import SparkMD5 from &#x27;spark-md5&#x27;;import $http from &#x27;../api/api&#x27;;//错误信息function getError(action, option, xhr) &#123; let msg; if (xhr.response) &#123; msg = `$&#123;xhr.response.error || xhr.response&#125;`; &#125; else if (xhr.responseText) &#123; msg = `$&#123;xhr.responseText&#125;`; &#125; else &#123; msg = `fail to post $&#123;action&#125; $&#123;xhr.status&#125;`; &#125; const err = new Error(msg); err.status = xhr.status; err.method = &#x27;post&#x27;; err.url = action; return err;&#125;// 上传成功完成合并之后，获取服务器返回的jsonfunction getBody(xhr) &#123; const text = xhr.responseText || xhr.response; if (!text) &#123; return text; &#125; try &#123; return JSON.parse(text); &#125; catch (e) &#123; return text; &#125;&#125;// 分片上传的自定义请求，以下请求会覆盖element的默认上传行为export default function upload(option) &#123; if (typeof XMLHttpRequest === &#x27;undefined&#x27;) &#123; return; &#125; const spark = new SparkMD5.ArrayBuffer(); // md5的ArrayBuffer加密类 const fileReader = new FileReader(); // 文件读取类 const action = option.action; // 文件上传上传路径 const chunkSize = 1024 * 1024 * 5; // 单个分片大小，这里测试用1m let md5 = &#x27;&#x27;; // 文件的唯一标识 const optionFile = option.file; // 需要分片的文件 let fileChunkedList = []; // 文件分片完成之后的数组 const percentage = []; // 文件上传进度的数组，单项就是一个分片的进度 // 文件开始分片，push到fileChunkedList数组中， 并用第一个分片去计算文件的md5 for (let i = 0; i &lt; optionFile.size; i = i + chunkSize) &#123; const tmp = optionFile.slice(i, Math.min(i + chunkSize, optionFile.size)); if (i === 0) &#123; fileReader.readAsArrayBuffer(tmp); &#125; fileChunkedList.push(tmp); &#125; // 在文件读取完毕之后，开始计算文件md5，作为文件唯一标识 fileReader.onload = async (e) =&gt; &#123; spark.append(e.target.result); md5 = spark.end() + new Date().getTime(); // console.log(&#x27;文件唯一标识--------&#x27;, md5); // 将fileChunkedList转成FormData对象，并加入上传时需要的数据 fileChunkedList = fileChunkedList.map((item, index) =&gt; &#123; const formData = new FormData(); if (option.data) &#123; // 额外加入外面传入的data数据 Object.keys(option.data).forEach((key) =&gt; &#123; formData.append(key, option.data[key]); &#125;); &#125; // 这些字段看后端需要哪些，就传哪些，也可以自己追加额外参数 formData.append(option.filename, item, option.file.name); // 文件 formData.append(&#x27;fileType&#x27;, option.file.type.split(&#x27;/&#x27;)[1]); // 文件 formData.append(&#x27;chunkNumber&#x27;, index + 1); // 当前文件块 // formData.append(&#x27;chunkSize&#x27;, chunkSize); // 单个分块大小 // formData.append(&#x27;currentChunkSize&#x27;, item.size); // 当前分块大小 // formData.append(&#x27;totalSize&#x27;, optionFile.size); // 文件总大小 formData.append(&#x27;identifier&#x27;, md5); // 文件标识 formData.append(&#x27;filename&#x27;, option.file.name); // 文件名 formData.append(&#x27;totalChunks&#x27;, fileChunkedList.length); // 总块数 return &#123; formData: formData, index: index &#125;; &#125;); // 更新上传进度条百分比的方法 const updataPercentage = (e) =&gt; &#123; let loaded = 0; // 当前已经上传文件的总大小 percentage.forEach((item) =&gt; &#123; loaded += item; &#125;); e.percent = (loaded / optionFile.size) * 100; option.onProgress(e); &#125;; // 创建队列上传任务，limit是上传并发数，默认会用两个并发 function sendRequest(chunks, limit = 2) &#123; return new Promise((resolve, reject) =&gt; &#123; const len = chunks.length; let counter = 0; let isStop = false; const start = async () =&gt; &#123; if (isStop) &#123; return; &#125; const item = chunks.shift(); // console.log(); if (item) &#123; const xhr = new XMLHttpRequest(); const index = item.index; // 分片上传失败回调 xhr.onerror = function error(e) &#123; isStop = true; reject(e); &#125;; // 分片上传成功回调 xhr.onload = function onload() &#123; if (xhr.status &lt; 200 || xhr.status &gt;= 300) &#123; isStop = true; reject(getError(action, option, xhr)); &#125; if (counter === len - 1) &#123; // 最后一个上传完成 resolve(len); &#125; else &#123; counter++; start(); &#125; &#125;; // 分片上传中回调 if (xhr.upload) &#123; xhr.upload.onprogress = function progress(e) &#123; if (e.total &gt; 0) &#123; e.percent = (e.loaded / e.total) * 100; &#125; percentage[index] = e.loaded; // console.log(index); updataPercentage(e); &#125;; &#125; xhr.open(&#x27;post&#x27;, action, true); if (option.withCredentials &amp;&amp; &#x27;withCredentials&#x27; in xhr) &#123; xhr.withCredentials = true; &#125; const headers = option.headers || &#123;&#125;; for (const item in headers) &#123; if (headers.hasOwnProperty(item) &amp;&amp; headers[item] !== null) &#123; xhr.setRequestHeader(item, headers[item]); &#125; &#125; // 文件开始上传 xhr.send(item.formData); &#125; &#125;; while (limit &gt; 0) &#123; setTimeout(() =&gt; &#123; start(); &#125;, Math.random() * 1000); limit -= 1; &#125; &#125;); &#125; try &#123; // 调用上传队列方法，提醒后端已上传完成，合并分片的文件 await sendRequest(fileChunkedList, 2).then((len) =&gt; &#123; $http .upload(&#123; data: &#123; identifier: md5, filename: option.file.name, totalSize: optionFile.size, totalChunks: len &#125;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; &#125; &#125;) .then((res) =&gt; &#123; if (+res.errNo === 0) &#123; option.onSuccess(res); return; &#125; else &#123; option.onError(res); return; &#125; &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); &#125;); // 这里的参数根据自己实际情况写 /* const data = &#123; identifier: md5, filename: option.file.name, totalSize: optionFile.size, totalChunks: fileChunkedList.length &#125;; */ // 给后端发送文件合并请求 /* const fileInfo = await this.axios( &#123; method: &#x27;post&#x27;, url: &#x27;/handwrite/outline/outlineupload&#x27;, data: this.qs.stringify(data) &#125;, &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; &#125; &#125; ).catch((error) =&gt; &#123; console.log(&#x27;ERRRR:: &#x27;, error.response.data); &#125;); if (fileInfo.data.code === 200) &#123; const success = getBody(fileInfo.request); option.onSuccess(success); return; &#125; */ &#125; catch (error) &#123; option.onError(error); &#125; &#125;;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Tispy Dr"},{"title":"react-hooks笔记","slug":"react-hooks笔记","date":"2022-03-29T11:07:00.000Z","updated":"2023-01-31T04:02:21.082Z","comments":true,"path":"2022/03/29/react-hooks笔记/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/29/react-hooks%E7%AC%94%E8%AE%B0/","excerpt":"","text":"react 官网中有关hooks使用的一些建议记录下来 提醒自己平时注意下 useStateuseState() 我们推荐把 state 切分成多个 state 变量，每个变量包含的不同值会在同时发生变化。 我们可以把组件的 state 拆分为 A 和 B 两个对象，并永远以非合并的方式去替换 A或者B 不需要render的场景下尾了避免组件重新渲染，可以使用useRef代替useState useRefuseRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。 effecteffect 是在绘制之后，延迟渲染的 useEffect、useMemo、useCallback 或 useImperativeHandle如果你指定了一个 依赖列表 作为 useEffect、useMemo、useCallback 或 useImperativeHandle 的最后一个参数，它必须包含回调中的所有值，并参与 React 数据流。这就包括 props、state，以及任何由它们衍生而来的东西。 只有 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略 react-router一般要使用link来代替代码中利用 react-router 做的router.push或者router.replace 这种跳转，其实这样写也没什么问题，就是不符合 Accessibility （易访问性设计）的要求123 Go to welcome callback通常为了测量dom节点的位置或者是大小的基本方式是使用callback ref。每当ref被附加到另一个节点，react就会调用callback。 待完善","categories":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"},{"name":"react hooks","slug":"react-hooks","permalink":"http://zhuxiaohan.xyz/tags/react-hooks/"}],"author":"Tispy Dr"},{"title":"页面字段高亮怎么做","slug":"页面字段高亮怎么做","date":"2022-03-29T11:01:00.000Z","updated":"2023-01-31T04:02:21.087Z","comments":true,"path":"2022/03/29/页面字段高亮怎么做/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/29/%E9%A1%B5%E9%9D%A2%E5%AD%97%E6%AE%B5%E9%AB%98%E4%BA%AE%E6%80%8E%E4%B9%88%E5%81%9A/","excerpt":"","text":"可能有些需求会有一些做字段高亮的需求，简单粗暴一点的方法就是 12345let seachText = &#x27;枚举&#x27;;const regexp = new RegExp(seachText, &#x27;g&#x27;);let content = $(&#x27;#content&#x27;).html();let newHtml = content.replace(regexp, &#x27;&lt;span class=&quot;highlight-word&quot; style=&quot;background: #ff0; color: #f00;&quot;&gt;&#x27; + seachText + &#x27;&lt;/span&gt;&#x27;);$(&#x27;#content&#x27;).html(newHtml);","categories":[],"tags":[],"author":"Tispy Dr"},{"title":"一个 react 写的 文字Logo气泡特效","slug":"一个-react-写的-文字Logo气泡特效","date":"2022-03-29T10:20:00.000Z","updated":"2023-01-31T04:02:21.082Z","comments":true,"path":"2022/03/29/一个-react-写的-文字Logo气泡特效/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/29/%E4%B8%80%E4%B8%AA-react-%E5%86%99%E7%9A%84-%E6%96%87%E5%AD%97Logo%E6%B0%94%E6%B3%A1%E7%89%B9%E6%95%88/","excerpt":"","text":"这个特效主要是使用 css3 实现，效果就是如图气泡漂浮的效果 css 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import styled from &#x27;styled-components&#x27;;export const TextWrap = styled.div` text-align: center; cursor: pointer;`;export const Bubble = styled.div` position: relative; .particle &#123; opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; &#125; @-webkit-keyframes bubbles &#123; 0% &#123; opacity: 0; &#125; 20% &#123; opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); &#125; 100% &#123; opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); &#125; &#125; @keyframes bubbles &#123; 0% &#123; opacity: 0; &#125; 20% &#123; opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); &#125; 100% &#123; opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); &#125; &#125;`;export const Text = styled.div` width: 100px; height: 50px; display: flex; flex-direction: column; justify-content: space-around; line-height: normal; align-items: center; color: #fff; font-weight: bold;`; tsx代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; FC &#125; from &#x27;react&#x27;;import &#123; TextWrap, Bubble, Text &#125; from &#x27;./styled&#x27;;import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;;interface Props &#123; path?: string; title: string; subTitle?: string;&#125;export const Logo: FC&lt;Props&gt;= (props) =&gt; &#123; const &#123; path, title, subTitle &#125; = props; const navigate = useNavigate(); const rnd = function (m: string, n: string)&#123; const m1 = parseInt(m); const n1 = parseInt(n); return Math.floor(Math.random() * (n1 - m1 + 1)) + m1; &#125; const CreateBubbles = function() &#123; const bubbleCount = 20; let dom = []; for (var i = 0; i &lt;= bubbleCount; i++) &#123; const size = rnd(&#x27;6&#x27;, &#x27;12&#x27;); const top = rnd(&#x27;20&#x27;, &#x27;80&#x27;) + &#x27;%&#x27;; const left = rnd(&#x27;0&#x27;, &#x27;95&#x27;) + &#x27;%&#x27;; const width = size + &#x27;px&#x27;; const height = size + &#x27;px&#x27;; const animation = rnd(&#x27;0&#x27;, &#x27;30&#x27;) / 10 + &#x27;s&#x27;; const style = &#123; top: top, left: left, width: width, height: height, animationDelay: animation, &#125;; dom.push(&lt;span className=&quot;particle&quot; style=&#123;style&#125; key=&#123;i&#125;&gt;&lt;/span&gt;); &#125; return ( &lt;&gt; &#123;...dom&#125; &lt;/&gt; ); &#125; const go = function() &#123; path ? window.location.href = path : &#x27;&#x27;; &#125; return ( &lt;&gt; &lt;TextWrap onClick=&#123;go&#125;&gt; &lt;Bubble&gt; &lt;CreateBubbles /&gt; &lt;Text&gt; &lt;span&gt;&#123;title&#125;&lt;/span&gt; &lt;span&gt;&#123;subTitle&#125;&lt;/span&gt; &lt;/Text&gt; &lt;/Bubble&gt; &lt;/TextWrap&gt; &lt;/&gt; );&#125;; 使用1&lt;Logo path=&#x27;/bagset&#x27; title=&#x27;TRUNK&#x27; subTitle=&#x27; 主线科技&#x27;/&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"},{"name":"组件","slug":"组件","permalink":"http://zhuxiaohan.xyz/tags/%E7%BB%84%E4%BB%B6/"},{"name":"react 组件","slug":"react-组件","permalink":"http://zhuxiaohan.xyz/tags/react-%E7%BB%84%E4%BB%B6/"}],"author":"Tispy Dr"},{"title":"Markdown支持的代码块语法高亮","slug":"Markdown支持的代码块语法高亮","date":"2022-03-29T07:10:00.000Z","updated":"2023-01-31T04:02:21.078Z","comments":true,"path":"2022/03/29/Markdown支持的代码块语法高亮/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/29/Markdown%E6%94%AF%E6%8C%81%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/","excerpt":"","text":"Markdown支持高亮显示的语言支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 用法1``` python","categories":[],"tags":[],"author":"Tispy Dr"},{"title":"实现一个自动注册的 Icon 组件","slug":"现一个自动注册的-Icon-组件","date":"2022-03-29T05:46:00.000Z","updated":"2023-01-31T04:02:21.085Z","comments":true,"path":"2022/03/29/现一个自动注册的-Icon-组件/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/29/%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E7%9A%84-Icon-%E7%BB%84%E4%BB%B6/","excerpt":"","text":"react 项目中我们难免会用到 自定义的 Icon，而我们使用 Icon 一般都是渲染 Svg 其中&gt;的好处就是 svg 可编辑，可搜索、索引、脚本化、可压缩，可以在图片质量不下降的情况&gt;下被放大，可以在任何分辨率下被高质量打印； 所以我们一般会在项目中封装一个自动注册 SVG 图标的 Icon 组件，因为我的项目是利用 vite 搭建的所以会引入vite-plugin-svgr的插件; 组件封装引入 vite-plugin-svgr1yarn add vite-plugin-svgr -D 使用 vite-plugin-svgr1234567import svgr from &#x27;vite-plugin-svgr&#x27;// 在plugins中plugins: [ reactRefresh(), svgr(),] 设置存放图标 svg 静态文件的目录1在 assets 目录下设置 Icons 文件夹，将所有的 svg 存放在此处，svg文件的名称即我们使用组件时需要传入的 type 字段，用来指定是哪个Icon 编写自动注册的 Icon 组件1234567891011121314151617181920212223242526272829303132import &#123; FC &#125; from &#x27;react&#x27;;import &#123; IconTypes &#125; from &#x27;@/types&#x27;;const modules = import.meta.globEager(&#x27;/src/assets/Icons/**/*.svg&#x27;);const icons: any = &#123;&#125;;const iconNames: string[] = Object.keys(modules);iconNames.forEach(key =&gt; &#123; const type: IconTypes = key as IconTypes; const icon: unknown = modules[type].ReactComponent; const name: IconTypes = key.match(/\\/Icons\\/(\\S*).svg/)![1] as IconTypes; icons[name] = icon;&#125;);interface CustomIconProps &#123; type?: IconTypes;&#125;const CustomIcon: FC&lt;CustomIconProps&gt; = props =&gt; &#123; const &#123; type &#125; = props; if (!type) return &lt;span className=&quot;anticon&quot;&gt;&lt;/span&gt;; const Icon = icons[type]; return ( &lt;span className=&quot;anticon&quot;&gt; &lt;Icon /&gt; &lt;/span&gt; );&#125;;export default CustomIcon; 使用方法1&lt;CustomIcon type=&#123;&#x27;svg 文件不带有后缀的文件名&#x27;&#125; /&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"},{"name":"组件","slug":"组件","permalink":"http://zhuxiaohan.xyz/tags/%E7%BB%84%E4%BB%B6/"},{"name":"react 组件","slug":"react-组件","permalink":"http://zhuxiaohan.xyz/tags/react-%E7%BB%84%E4%BB%B6/"}],"author":"Tispy Dr"},{"title":"配置环境变量后接口地址总是会有部分路由","slug":"配置环境变量后接口地址总是会有部分路由","date":"2022-03-07T11:15:00.000Z","updated":"2023-01-31T04:02:21.087Z","comments":true,"path":"2022/03/07/配置环境变量后接口地址总是会有部分路由/","link":"","permalink":"http://zhuxiaohan.xyz/2022/03/07/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E6%80%BB%E6%98%AF%E4%BC%9A%E6%9C%89%E9%83%A8%E5%88%86%E8%B7%AF%E7%94%B1/","excerpt":"","text":"原因：主要是因为 .env.development 这个文件 中 VITE_BASE_URL=&#39;/mock/12&#39; mock 前边没有加 / ， 造成了每个请求都加上了路由的一个地址","categories":[],"tags":[],"author":"Tispy Dr"},{"title":"美化终端：zsh 和 on-my-zsh 配置","slug":"美化终端：zsh-和-on-my-zsh-配置","date":"2022-02-23T01:50:00.000Z","updated":"2023-01-31T04:02:21.086Z","comments":true,"path":"2022/02/23/美化终端：zsh-和-on-my-zsh-配置/","link":"","permalink":"http://zhuxiaohan.xyz/2022/02/23/%E7%BE%8E%E5%8C%96%E7%BB%88%E7%AB%AF%EF%BC%9Azsh-%E5%92%8C-on-my-zsh-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"zsh当前环境 shell 1echo $SHELL 查看系统自带哪些 shell 1cat /etc/shells 安装 zsh 12yum install zsh # CentOSbrew install zsh # mac安装 将zsh设置为默认shell 123456789# CentOSchsh -s /bin/zsh # Mac如下# 在 /etc/shells 文件中加入如下一行/usr/local/bin/zsh# 接着运行chsh -s /usr/local/bin/zsh oh-my-zsh ohmyz https://ohmyz.sh/ github https://github.com/robbyrussell/oh-my-zsh 安装 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 查看主题 1ls ~/.oh-my-zsh/themes 修改zsh主题 123$ vim ~/.zshrcsource ~/.bash_profile # 增加这行","categories":[],"tags":[{"name":"zsh","slug":"zsh","permalink":"http://zhuxiaohan.xyz/tags/zsh/"}],"author":"Tispy Dr"},{"title":"Docker的使用","slug":"Docker的使用","date":"2022-02-18T10:47:00.000Z","updated":"2023-01-31T04:02:21.078Z","comments":true,"path":"2022/02/18/Docker的使用/","link":"","permalink":"http://zhuxiaohan.xyz/2022/02/18/Docker%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"docker是什么docker 可以帮我们磨平不同系统的应用程序的安装差异，一个命令，多系统无差别快速安装可以轻松的将项目安装在不同的机器上，本地、其他人的、公司内网公共测试服务器或者自己的某云服务器 Q： 为什么 docker 能帮我们磨平不同系统的应用程序的安装差异？ docker基础 镜像：就是像是我们装机时候需要的系统盘或者系统镜像文件，这里它负责创建docker容器的，有很多官方现成的镜像：node、mysql、monogo、nginx可以从远程仓库下载 容器：可以比拟成一个迷你的系统，例如一个只安装mysql5.7的linux最小系统，当然你喜欢也可以把mysql、node安装在同一个容器中，记住，容器与容器，容器和主机都是互相隔离的 仓库：仓库就像是github那样的，我们可以制作镜像然后push 提交到云端的仓库，也可以从仓库 pull 下载镜像 安装docker的安装很简单，win、osx都是图形界面安装，linux的也几行命令,现在的mac的m1芯片系列也支持了，这里我们先略过安装步骤，要快！先看完！ ps: 在m1芯片的docker上安装mysql需要稍加点配置 安装完运行下方代码查看 12docker -v 创建运行docker容器12345678910111213141516# 0 先进入我们项目的文件夹位置cd my-repository# 1 执行pwd可以获取当前文件夹在电脑的绝对目录pwd# /Users/eric/my-repository# 2 运行创建docker容器1：承载 react+webpack+nodejs10docker run -it -d --name myreact --privileged -p 8081:8080 -v /Users/eric/my-repository/my-app-react:/app/react node:10.16.2 /bin/bash -c &quot;cd /app/react &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run serve&quot;# 3 运行创建docker容器2：承载 vue3+vite+nodejs12docker run -it -d --name myvue3 --privileged -p 8080:3000 -v /Users/eric/my-repository/my-app-vue3:/app/vue node:12.22.6 /bin/bash -c &quot;cd /app/vue &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run dev&quot;# 4 运行成功后 查看容器运行情况docker ps -a 成功运行后我们可以看到容器的启动状态、端口映射、容器名字 如果出错可运行如下命令查看原因 12docker logs -f container_id/containe_name 这个docker run 是可以用来创建同时启动运行容器先换行来看 : shell 脚本太长的时候我们可以用 “&quot;把一行命令分成多行 12345678910docker run \\-it \\-d \\ --name myreact \\--privileged \\-p 8081:8080 \\-v /Users/eric/my-repository/my-app-react:/app/react \\node:10.16.2 \\/bin/bash -c &quot;cd /app/react &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run serve&quot; 我们可以使用 docker run 命令可以下载镜像 -&gt;通过镜像创建容器 -&gt;启动运行容器 参数解析： 参数 描述 -d 以守护进程的方式让容器在后台运行，在这您之 前可能使用的是pm2来守护进程 -it 这里是 -i和 -t的缩写-i：告诉 Docker 容器保持标准输入流对容器开放,即使容器没有终端连接告诉 Docker 为容器分配一个虚拟终端 –name myreact 将容器命名为 myreact2，这样访问和操作容 器等就不需要输入一大串的容器ID –privileged 让容器的用户在容器内能获取完全root权限 -p 8081:8080 将容器的8080端口映射到宿主机的8081端口上这样我们访问本机的localhost:8081,就是访问到容器的8080端口因为容器都是独立运行互相隔离的，容器与容器各自的8080端口、容器跟主机各自的8080端口都不是一个东西，主机只有在这给端口做映射才能访问到容器端口 -v /Users/eric/my-repository/my-app-react:/app/react 将主机的my-app-react目录(命令行这里只能写绝对路径哈)下的内容挂载到容器的目录/app/react内如果容器的指定目录有文件/文件夹，将被清空挂载后，容器修改 /app/react目录的内容，也是在修改主机目录/Users/eric/my-repository/my-app-react内容 node:10.16.2 这里是指定nodejs，版本为10.16.2的镜像来创建容器如果不指定版本，会默认下载当前镜像的最新版本 /bin/bash -c “cd /app/react &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run serve” /bin/bash：是在让容器分配的虚拟终端以 bash 模式执行命令-c “”cd /app/react &amp;&amp; node -v &amp;&amp; npm install &amp;&amp; npm run serve：只能执行一条 shell 命令，需要多个命令按需用&amp;&amp;、 上面代码运行成功后我们的电脑就会有两个互相隔离独立运行的docker容器 node10+react+webpacknode+vue3+vite 现在我们的电脑同事运行nodejs10、nodejs12的项目了他们是相互独立隔离运行的，以此类推我们还可以有更多的容器 调试 常用的调试命令11docker logs -f contianer_name/container_id 当容器内正在进行编译或者发生错误甚至退出的时候，我们可用此命令查看终端输出的信息例子运行成功后，查看myreact 容器的npm run serve 在终端上的实时输出信息1docker logs -f react 常用的调试命令 21docker inspect react 常用操作命令 常用的操作命令表一栏 镜像操作命令 12345678910111213141516171819# 搜索镜像docker search [images_name:tag]# 下载镜像（：指定版本）docker pull [images_name:tag]# 查看本地下载的镜像docker images# 自己构建镜像# 根据dockerfile的路径或者url构建镜像 docker build [OPTIONS] PATH|URL|-# 查看镜像的构建历史docker history [images_name]# 删除镜像# 需要先删除以此镜像为基础的容器 docker rmi [images_name] 容器操作命令 1234567891011121314151617181920212223242526272829303132333435# 查看运行中的容器# 可以查看容器ID、基础镜像、容器名称、运行状态、端口映射等docker ps# 查看所有容器：包括停止的docker ps -a# 查看容器的信息# 例如端口号的映射、目录挂载docker inspect [images_name/images_id]# 启动和停止容器docker start/stop [container_name/container_id]# 重启容器# 使用场景实例：# 在加入新的npm包依赖需要重新编译的时候使用重启运行编译# nginx容器的配置更新后需要重启生效docker restart [container_name/container_id]# 进入容器# ps:有些容器没有bash,需要改成/bin/sh，例如mysq、mongodb的# 退出人容器输入exit 回车键docker exec -it [container_name/container_id] /bin/bash# 删除容器# 在容器停止的状态才能删docker rm [container_name/container_id]# 容器主机文件拷# 将容器文件拷贝到主机docker cp [container_id/container_name] : [文件目录] [主机目录]# 将主机的目录拷贝到容器docker cp [主机目录] [container_id/container_name] : [文件目录] 进阶果没有合适的镜像，我们通常用Dockerfile来构建自定义镜像发现没，上面的docker run 只能创建启动一个docker容器，我们可以用docker-compose来一次启动多个容器，常用于单机下安装多个服务慢点再来更新，大家有兴趣也可以先看到我用docker 部署的Jenkins自动化部署 CI/CD 环境 里面也有docker-compose的使用","categories":[{"name":"Docker","slug":"Docker","permalink":"http://zhuxiaohan.xyz/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhuxiaohan.xyz/tags/Docker/"}],"author":"Tispy Dr"},{"title":"Hello World","slug":"hello-world","date":"2022-02-11T13:07:00.000Z","updated":"2022-02-11T14:49:42.618Z","comments":true,"path":"2022/02/11/hello-world/","link":"","permalink":"http://zhuxiaohan.xyz/2022/02/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"欢迎 嗨","slug":"欢迎-嗨","permalink":"http://zhuxiaohan.xyz/categories/%E6%AC%A2%E8%BF%8E-%E5%97%A8/"}],"tags":[{"name":"欢迎","slug":"欢迎","permalink":"http://zhuxiaohan.xyz/tags/%E6%AC%A2%E8%BF%8E/"}]},{"title":"Mac查看端口","slug":"Mac查看端口","date":"2022-02-11T09:30:00.000Z","updated":"2022-02-11T13:07:24.212Z","comments":true,"path":"2022/02/11/Mac查看端口/","link":"","permalink":"http://zhuxiaohan.xyz/2022/02/11/Mac%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"Mac查看端口并杀死进程查看端口被那个进程占用 sudo lsof -i tcp:8082 利用进程的PID，将进程杀死 sudo kill -9 PID","categories":[{"name":"Mac指令","slug":"Mac指令","permalink":"http://zhuxiaohan.xyz/categories/Mac%E6%8C%87%E4%BB%A4/"}],"tags":[],"author":"Tispy Dr"},{"title":"DS_Store 是什么","slug":"DS-Store-是什么","date":"2022-02-11T07:50:00.000Z","updated":"2022-02-11T13:07:24.212Z","comments":true,"path":"2022/02/11/DS-Store-是什么/","link":"","permalink":"http://zhuxiaohan.xyz/2022/02/11/DS-Store-%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":".DS_Store 是什么之前用node批量做文件处理的时候突然发生了报错，之后发现是文件夹中多了DS_Store文件查询之后发现 .DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存储目录的自定义属性，例如文件的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。 删除.DS_Store如果你的项目中还没有自动生成的 .DS_Store 文件，那么直接将 .DS_Store 加入到 .gitignore 文件就可以了。如果你的项目中已经存在 .DS_Store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下： 1. 删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 2. 将 .DS_Store 加入到 .gitignore 3. echo .DS_Store &gt;&gt; ~/.gitignore 4. 更新项目 5. git add --all 6. git commit -m &#39;.DS_Store banished!&#39; 如果你只需要删除磁盘上的 .DS_Store，可以使用下面的命令来删除当前目录及其子目录下的所有.DS_Store 文件: find . -name &#39;*.DS_Store&#39; -type f -delete 禁用或启用自动生成禁止.DS_store生成： defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 恢复.DS_store生成：恢复.DS_store生成： defaults delete com.apple.desktopservices DSDontWriteNetworkStores","categories":[{"name":"Mac指令","slug":"Mac指令","permalink":"http://zhuxiaohan.xyz/categories/Mac%E6%8C%87%E4%BB%A4/"}],"tags":[],"author":"John Doe"},{"title":"关于","slug":"about","date":"2022-01-21T09:11:00.000Z","updated":"2022-02-14T02:23:38.450Z","comments":true,"path":"2022/01/21/about/","link":"","permalink":"http://zhuxiaohan.xyz/2022/01/21/about/","excerpt":"","text":"博客搭建利用的技术 Hexo: 快速、简洁且高效的博客框架 Butterfly: Hexo的主题，可以让我们的博客更加的好看 twikoo: 一款快速、简洁且高效的无后端评论系统，因为暂时没有图床的原因，图片会默认被转为 base64 进行保存 Hexo-admin 一款可以管理静态博客的后台，目前是pm2跑在阿里云服务器中 操作 仅支持markdown语法 添加pages或者posts的操作可以参考 Hexo写作 写作可以把代码中编辑之后执行hexo clean &amp;&amp; hexo deploy 也可以在admin 中直接写作 然后点击导航中的 Deploy 生成 html 并部署，部署的时候可以添加commit信息，因为admin是一下子引入的所以体积比较大，会加载一段时间","categories":[{"name":"关于","slug":"关于","permalink":"http://zhuxiaohan.xyz/categories/%E5%85%B3%E4%BA%8E/"}],"tags":[{"name":"关于","slug":"关于","permalink":"http://zhuxiaohan.xyz/tags/%E5%85%B3%E4%BA%8E/"}],"author":"test"}],"categories":[{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/categories/react/"},{"name":"药方","slug":"药方","permalink":"http://zhuxiaohan.xyz/categories/%E8%8D%AF%E6%96%B9/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/"},{"name":"feature","slug":"feature","permalink":"http://zhuxiaohan.xyz/categories/feature/"},{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/categories/js/"},{"name":"推荐文章","slug":"推荐文章","permalink":"http://zhuxiaohan.xyz/categories/%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/"},{"name":"vue","slug":"vue","permalink":"http://zhuxiaohan.xyz/categories/vue/"},{"name":"react","slug":"前端/react","permalink":"http://zhuxiaohan.xyz/categories/%E5%89%8D%E7%AB%AF/react/"},{"name":"Docker","slug":"Docker","permalink":"http://zhuxiaohan.xyz/categories/Docker/"},{"name":"欢迎 嗨","slug":"欢迎-嗨","permalink":"http://zhuxiaohan.xyz/categories/%E6%AC%A2%E8%BF%8E-%E5%97%A8/"},{"name":"Mac指令","slug":"Mac指令","permalink":"http://zhuxiaohan.xyz/categories/Mac%E6%8C%87%E4%BB%A4/"},{"name":"关于","slug":"关于","permalink":"http://zhuxiaohan.xyz/categories/%E5%85%B3%E4%BA%8E/"}],"tags":[{"name":"js","slug":"js","permalink":"http://zhuxiaohan.xyz/tags/js/"},{"name":"threejs","slug":"threejs","permalink":"http://zhuxiaohan.xyz/tags/threejs/"},{"name":"react","slug":"react","permalink":"http://zhuxiaohan.xyz/tags/react/"},{"name":"药方","slug":"药方","permalink":"http://zhuxiaohan.xyz/tags/%E8%8D%AF%E6%96%B9/"},{"name":"组件","slug":"组件","permalink":"http://zhuxiaohan.xyz/tags/%E7%BB%84%E4%BB%B6/"},{"name":"点云","slug":"点云","permalink":"http://zhuxiaohan.xyz/tags/%E7%82%B9%E4%BA%91/"},{"name":"预加载","slug":"预加载","permalink":"http://zhuxiaohan.xyz/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/"},{"name":"前端","slug":"前端","permalink":"http://zhuxiaohan.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"node","permalink":"http://zhuxiaohan.xyz/tags/node/"},{"name":"feature","slug":"feature","permalink":"http://zhuxiaohan.xyz/tags/feature/"},{"name":"项目","slug":"项目","permalink":"http://zhuxiaohan.xyz/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"设想","slug":"设想","permalink":"http://zhuxiaohan.xyz/tags/%E8%AE%BE%E6%83%B3/"},{"name":"mac","slug":"mac","permalink":"http://zhuxiaohan.xyz/tags/mac/"},{"name":"推荐文章","slug":"推荐文章","permalink":"http://zhuxiaohan.xyz/tags/%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/"},{"name":"MD5","slug":"MD5","permalink":"http://zhuxiaohan.xyz/tags/MD5/"},{"name":"vue","slug":"vue","permalink":"http://zhuxiaohan.xyz/tags/vue/"},{"name":"拖拽","slug":"拖拽","permalink":"http://zhuxiaohan.xyz/tags/%E6%8B%96%E6%8B%BD/"},{"name":"防抖 节流","slug":"防抖-节流","permalink":"http://zhuxiaohan.xyz/tags/%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/"},{"name":"面试题","slug":"面试题","permalink":"http://zhuxiaohan.xyz/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"git","slug":"git","permalink":"http://zhuxiaohan.xyz/tags/git/"},{"name":"react hooks","slug":"react-hooks","permalink":"http://zhuxiaohan.xyz/tags/react-hooks/"},{"name":"react 组件","slug":"react-组件","permalink":"http://zhuxiaohan.xyz/tags/react-%E7%BB%84%E4%BB%B6/"},{"name":"zsh","slug":"zsh","permalink":"http://zhuxiaohan.xyz/tags/zsh/"},{"name":"Docker","slug":"Docker","permalink":"http://zhuxiaohan.xyz/tags/Docker/"},{"name":"欢迎","slug":"欢迎","permalink":"http://zhuxiaohan.xyz/tags/%E6%AC%A2%E8%BF%8E/"},{"name":"关于","slug":"关于","permalink":"http://zhuxiaohan.xyz/tags/%E5%85%B3%E4%BA%8E/"}]}